// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// http://code.google.com/p/protobuf/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.

#include <cetty/config/generator/cpp/FileGenerator.h>

#include <cetty/config/generator/cpp/CppHelpers.h>
#include <cetty/config/generator/cpp/MessageGenerator.h>

#include <google/protobuf/io/printer.h>
#include <google/protobuf/descriptor.pb.h>

namespace cetty {
namespace config {
namespace generator {
namespace cpp {

using namespace google::protobuf;

// ----------------------------------------------------------------------
// SplitStringUsing()
//    Split a string using a character delimiter. Append the components
//    to 'result'.
//
// Note: For multi-character delimiters, this routine will split on *ANY* of
// the characters in the string, not the entire string as a single delimiter.
// ----------------------------------------------------------------------
template <typename ITR>
static inline
void SplitStringToIteratorUsing(const string& full,
                                const char* delim,
                                ITR& result) {
    // Optimize the common case where delim is a single character.
    if (delim[0] != '\0' && delim[1] == '\0') {
        char c = delim[0];
        const char* p = full.data();
        const char* end = p + full.size();

        while (p != end) {
            if (*p == c) {
                ++p;
            }
            else {
                const char* start = p;

                while (++p != end && *p != c);

                *result++ = string(start, p - start);
            }
        }

        return;
    }

    string::size_type begin_index, end_index;
    begin_index = full.find_first_not_of(delim);

    while (begin_index != string::npos) {
        end_index = full.find_first_of(delim, begin_index);

        if (end_index == string::npos) {
            *result++ = full.substr(begin_index);
            return;
        }

        *result++ = full.substr(begin_index, (end_index - begin_index));
        begin_index = full.find_first_not_of(delim, end_index);
    }
}

void SplitStringUsing(const string& full,
                      const char* delim,
                      vector<string>* result) {
    back_insert_iterator< vector<string> > it(*result);
    SplitStringToIteratorUsing(full, delim, it);
}

FileGenerator::FileGenerator(const FileDescriptor* file,
                             const string& dllexport_decl)
    : file_(file),
      message_generators_(
          new scoped_ptr<MessageGenerator>[file->message_type_count()]),
      dllexport_decl_(dllexport_decl) {

    for (int i = 0; i < file->message_type_count(); i++) {
        message_generators_[i].reset(
            new MessageGenerator(file->message_type(i), dllexport_decl));
    }

    SplitStringUsing(file_->package(), ".", &package_parts_);
}

FileGenerator::~FileGenerator() {}

void FileGenerator::GenerateHeader(io::Printer* printer) {
    string filename_identifier = FilenameIdentifier(file_->name());

    // Generate top of header.
    printer->Print(
        "// Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
        "// source: $filename$\n"
        "\n"
        "#if !defined(CETTY_CONFIG_$filename_identifier$__INCLUDED)\n"
        "#define CETTY_CONFIG_$filename_identifier$__INCLUDED\n"
        "\n"
        "#include <string>\n"
        "#include <vector>\n"
        "\n",
        "filename", file_->name(),
        "filename_identifier", filename_identifier);

    printer->Print("#include <cetty/config/ConfigObject.h>\n"
                   "#include <cetty/config/ConfigDescriptor.h>\n");

    if (file_->name() != "KeyValuePair") {
        printer->Print("#include <cetty/config/KeyValuePair.cnf.h>\n\n");
    }

    for (int i = 0; i < file_->dependency_count(); i++) {
        const std::string& dependency = file_->dependency(i)->name();

        if (dependency == "config") {
            continue;
        }

        printer->Print(
            "#include \"$dependency$.cnf.h\"\n",
            "dependency",
            StripProto(dependency));
    }

    // Open namespace.
    GenerateNamespaceOpeners(printer);

    printer->Print("\n");

    // Generate forward declarations of classes.
    for (int i = 0; i < file_->message_type_count(); i++) {
        message_generators_[i]->GenerateForwardDeclaration(printer);
    }

    printer->Print("\n");

    printer->Print(kThickSeparator);
    printer->Print("\n");

    // Generate class definitions.
    for (int i = 0; i < file_->message_type_count(); i++) {
        if (i > 0) {
            printer->Print("\n");
            printer->Print(kThinSeparator);
            printer->Print("\n");
        }

        message_generators_[i]->GenerateClassDefinition(printer);
    }

    printer->Print("\n");
    printer->Print(kThickSeparator);
    printer->Print("\n");

    // Close up namespace.
    GenerateNamespaceClosers(printer);

    printer->Print(
        "#endif  // CETTY_CONFIG_$filename_identifier$__INCLUDED\n",
        "filename_identifier", filename_identifier);
}

void FileGenerator::GenerateSource(io::Printer* printer) {
    printer->Print(
        "// Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
        "\n"

        // The generated code calls accessors that might be deprecated. We don't
        // want the compiler to warn in generated code.
        "#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION\n"
        "#include \"$basename$.cnf.h\"\n"
        "\n",
        "basename", StripProto(file_->name()));

    GenerateNamespaceOpeners(printer);

    // Generate classes.
    for (int i = 0; i < file_->message_type_count(); i++) {
        printer->Print("\n");
        printer->Print(kThickSeparator);
        printer->Print("\n");
        message_generators_[i]->GenerateStructors(printer);
        message_generators_[i]->GenerateTypeRegistrations(printer);
    }

    printer->Print("\n");

    GenerateNamespaceClosers(printer);
}

void FileGenerator::GenerateNamespaceOpeners(io::Printer* printer) {
    if (package_parts_.size() > 0) { printer->Print("\n"); }

    for (int i = 0; i < package_parts_.size(); i++) {
        printer->Print("namespace $part$ {\n",
                       "part", package_parts_[i]);
    }
}

void FileGenerator::GenerateNamespaceClosers(io::Printer* printer) {
    if (package_parts_.size() > 0) { printer->Print("\n"); }

    for (int i = package_parts_.size() - 1; i >= 0; i--) {
        printer->Print("}  // namespace $part$\n",
                       "part", package_parts_[i]);
    }
}

}
}
}
}
