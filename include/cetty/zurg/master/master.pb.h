// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cetty/zurg/master/master.proto

#ifndef PROTOBUF_cetty_2fzurg_2fmaster_2fmaster_2eproto__INCLUDED
#define PROTOBUF_cetty_2fzurg_2fmaster_2fmaster_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <cetty/protobuf/service/ProtobufService.h>
#include <cetty/protobuf/service/ProtobufServiceFuture.h>
#include <cetty/protobuf/service/ProtobufServiceMessagePtr.h>
#include <cetty/protobuf/service/ProtobufClientServiceAdaptor.h>
#include "cetty/protobuf/service/service.pb.h"
#include "cetty/zurg/slave/slave.pb.h"
// @@protoc_insertion_point(includes)

namespace cetty {
namespace zurg {
namespace master {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cetty_2fzurg_2fmaster_2fmaster_2eproto();
void protobuf_AssignDesc_cetty_2fzurg_2fmaster_2fmaster_2eproto();
void protobuf_ShutdownFile_cetty_2fzurg_2fmaster_2fmaster_2eproto();

class SlaveHeartbeat;
class SlaveHeartbeat_Uname;

// ===================================================================

class SlaveHeartbeat_Uname : public ::google::protobuf::Message {
 public:
  SlaveHeartbeat_Uname();
  virtual ~SlaveHeartbeat_Uname();
  
  SlaveHeartbeat_Uname(const SlaveHeartbeat_Uname& from);
  
  inline SlaveHeartbeat_Uname& operator=(const SlaveHeartbeat_Uname& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveHeartbeat_Uname& default_instance();
  
  void Swap(SlaveHeartbeat_Uname* other);
  
  // implements Message ----------------------------------------------
  
  SlaveHeartbeat_Uname* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveHeartbeat_Uname& from);
  void MergeFrom(const SlaveHeartbeat_Uname& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sys_name = 1;
  inline bool has_sys_name() const;
  inline void clear_sys_name();
  static const int kSysNameFieldNumber = 1;
  inline const ::std::string& sys_name() const;
  inline void set_sys_name(const ::std::string& value);
  inline void set_sys_name(const char* value);
  inline void set_sys_name(const char* value, size_t size);
  inline ::std::string* mutable_sys_name();
  inline ::std::string* release_sys_name();
  
  // required string node_name = 2;
  inline bool has_node_name() const;
  inline void clear_node_name();
  static const int kNodeNameFieldNumber = 2;
  inline const ::std::string& node_name() const;
  inline void set_node_name(const ::std::string& value);
  inline void set_node_name(const char* value);
  inline void set_node_name(const char* value, size_t size);
  inline ::std::string* mutable_node_name();
  inline ::std::string* release_node_name();
  
  // required string release = 3;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 3;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  inline ::std::string* release_release();
  
  // required string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required string machine = 5;
  inline bool has_machine() const;
  inline void clear_machine();
  static const int kMachineFieldNumber = 5;
  inline const ::std::string& machine() const;
  inline void set_machine(const ::std::string& value);
  inline void set_machine(const char* value);
  inline void set_machine(const char* value, size_t size);
  inline ::std::string* mutable_machine();
  inline ::std::string* release_machine();
  
  // required string domain_name = 6;
  inline bool has_domain_name() const;
  inline void clear_domain_name();
  static const int kDomainNameFieldNumber = 6;
  inline const ::std::string& domain_name() const;
  inline void set_domain_name(const ::std::string& value);
  inline void set_domain_name(const char* value);
  inline void set_domain_name(const char* value, size_t size);
  inline ::std::string* mutable_domain_name();
  inline ::std::string* release_domain_name();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.master.SlaveHeartbeat.Uname)
 private:
  inline void set_has_sys_name();
  inline void clear_has_sys_name();
  inline void set_has_node_name();
  inline void clear_has_node_name();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_machine();
  inline void clear_has_machine();
  inline void set_has_domain_name();
  inline void clear_has_domain_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sys_name_;
  ::std::string* node_name_;
  ::std::string* release_;
  ::std::string* version_;
  ::std::string* machine_;
  ::std::string* domain_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fmaster_2fmaster_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fmaster_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fmaster_2fmaster_2eproto();
  
  void InitAsDefaultInstance();
  static SlaveHeartbeat_Uname* default_instance_;
};
// -------------------------------------------------------------------

class SlaveHeartbeat : public ::google::protobuf::Message {
 public:
  SlaveHeartbeat();
  virtual ~SlaveHeartbeat();
  
  SlaveHeartbeat(const SlaveHeartbeat& from);
  
  inline SlaveHeartbeat& operator=(const SlaveHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveHeartbeat& default_instance();
  
  void Swap(SlaveHeartbeat* other);
  
  // implements Message ----------------------------------------------
  
  SlaveHeartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveHeartbeat& from);
  void MergeFrom(const SlaveHeartbeat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SlaveHeartbeat_Uname Uname;
  
  // accessors -------------------------------------------------------
  
  // required string slave_name = 1;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 1;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  
  // required int64 send_time_us = 2;
  inline bool has_send_time_us() const;
  inline void clear_send_time_us();
  static const int kSendTimeUsFieldNumber = 2;
  inline ::google::protobuf::int64 send_time_us() const;
  inline void set_send_time_us(::google::protobuf::int64 value);
  
  // optional string host_name = 20;
  inline bool has_host_name() const;
  inline void clear_host_name();
  static const int kHostNameFieldNumber = 20;
  inline const ::std::string& host_name() const;
  inline void set_host_name(const ::std::string& value);
  inline void set_host_name(const char* value);
  inline void set_host_name(const char* value, size_t size);
  inline ::std::string* mutable_host_name();
  inline ::std::string* release_host_name();
  
  // optional int32 listen_port = 21;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 21;
  inline ::google::protobuf::int32 listen_port() const;
  inline void set_listen_port(::google::protobuf::int32 value);
  
  // optional int32 slave_pid = 22;
  inline bool has_slave_pid() const;
  inline void clear_slave_pid();
  static const int kSlavePidFieldNumber = 22;
  inline ::google::protobuf::int32 slave_pid() const;
  inline void set_slave_pid(::google::protobuf::int32 value);
  
  // optional int64 start_time_us = 23;
  inline bool has_start_time_us() const;
  inline void clear_start_time_us();
  static const int kStartTimeUsFieldNumber = 23;
  inline ::google::protobuf::int64 start_time_us() const;
  inline void set_start_time_us(::google::protobuf::int64 value);
  
  // optional string slave_version = 24;
  inline bool has_slave_version() const;
  inline void clear_slave_version();
  static const int kSlaveVersionFieldNumber = 24;
  inline const ::std::string& slave_version() const;
  inline void set_slave_version(const ::std::string& value);
  inline void set_slave_version(const char* value);
  inline void set_slave_version(const char* value, size_t size);
  inline ::std::string* mutable_slave_version();
  inline ::std::string* release_slave_version();
  
  // repeated string env_vars = 25;
  inline int env_vars_size() const;
  inline void clear_env_vars();
  static const int kEnvVarsFieldNumber = 25;
  inline const ::std::string& env_vars(int index) const;
  inline ::std::string* mutable_env_vars(int index);
  inline void set_env_vars(int index, const ::std::string& value);
  inline void set_env_vars(int index, const char* value);
  inline void set_env_vars(int index, const char* value, size_t size);
  inline ::std::string* add_env_vars();
  inline void add_env_vars(const ::std::string& value);
  inline void add_env_vars(const char* value);
  inline void add_env_vars(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& env_vars() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_env_vars();
  
  // optional string cpuinfo = 30;
  inline bool has_cpuinfo() const;
  inline void clear_cpuinfo();
  static const int kCpuinfoFieldNumber = 30;
  inline const ::std::string& cpuinfo() const;
  inline void set_cpuinfo(const ::std::string& value);
  inline void set_cpuinfo(const char* value);
  inline void set_cpuinfo(const char* value, size_t size);
  inline ::std::string* mutable_cpuinfo();
  inline ::std::string* release_cpuinfo();
  
  // optional string version = 31;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 31;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string etc_mtab = 32;
  inline bool has_etc_mtab() const;
  inline void clear_etc_mtab();
  static const int kEtcMtabFieldNumber = 32;
  inline const ::std::string& etc_mtab() const;
  inline void set_etc_mtab(const ::std::string& value);
  inline void set_etc_mtab(const char* value);
  inline void set_etc_mtab(const char* value, size_t size);
  inline ::std::string* mutable_etc_mtab();
  inline ::std::string* release_etc_mtab();
  
  // optional string sysctl = 33;
  inline bool has_sysctl() const;
  inline void clear_sysctl();
  static const int kSysctlFieldNumber = 33;
  inline const ::std::string& sysctl() const;
  inline void set_sysctl(const ::std::string& value);
  inline void set_sysctl(const char* value);
  inline void set_sysctl(const char* value, size_t size);
  inline ::std::string* mutable_sysctl();
  inline ::std::string* release_sysctl();
  
  // optional .cetty.zurg.master.SlaveHeartbeat.Uname uname = 34;
  inline bool has_uname() const;
  inline void clear_uname();
  static const int kUnameFieldNumber = 34;
  inline const ::cetty::zurg::master::SlaveHeartbeat_Uname& uname() const;
  inline ::cetty::zurg::master::SlaveHeartbeat_Uname* mutable_uname();
  inline ::cetty::zurg::master::SlaveHeartbeat_Uname* release_uname();
  
  // optional string meminfo = 40;
  inline bool has_meminfo() const;
  inline void clear_meminfo();
  static const int kMeminfoFieldNumber = 40;
  inline const ::std::string& meminfo() const;
  inline void set_meminfo(const ::std::string& value);
  inline void set_meminfo(const char* value);
  inline void set_meminfo(const char* value, size_t size);
  inline ::std::string* mutable_meminfo();
  inline ::std::string* release_meminfo();
  
  // optional string proc_stat = 41;
  inline bool has_proc_stat() const;
  inline void clear_proc_stat();
  static const int kProcStatFieldNumber = 41;
  inline const ::std::string& proc_stat() const;
  inline void set_proc_stat(const ::std::string& value);
  inline void set_proc_stat(const char* value);
  inline void set_proc_stat(const char* value, size_t size);
  inline ::std::string* mutable_proc_stat();
  inline ::std::string* release_proc_stat();
  
  // optional string loadavg = 42;
  inline bool has_loadavg() const;
  inline void clear_loadavg();
  static const int kLoadavgFieldNumber = 42;
  inline const ::std::string& loadavg() const;
  inline void set_loadavg(const ::std::string& value);
  inline void set_loadavg(const char* value);
  inline void set_loadavg(const char* value, size_t size);
  inline ::std::string* mutable_loadavg();
  inline ::std::string* release_loadavg();
  
  // optional string diskstats = 43;
  inline bool has_diskstats() const;
  inline void clear_diskstats();
  static const int kDiskstatsFieldNumber = 43;
  inline const ::std::string& diskstats() const;
  inline void set_diskstats(const ::std::string& value);
  inline void set_diskstats(const char* value);
  inline void set_diskstats(const char* value, size_t size);
  inline ::std::string* mutable_diskstats();
  inline ::std::string* release_diskstats();
  
  // optional string net_dev = 44;
  inline bool has_net_dev() const;
  inline void clear_net_dev();
  static const int kNetDevFieldNumber = 44;
  inline const ::std::string& net_dev() const;
  inline void set_net_dev(const ::std::string& value);
  inline void set_net_dev(const char* value);
  inline void set_net_dev(const char* value, size_t size);
  inline ::std::string* mutable_net_dev();
  inline ::std::string* release_net_dev();
  
  // optional string net_tcp = 45;
  inline bool has_net_tcp() const;
  inline void clear_net_tcp();
  static const int kNetTcpFieldNumber = 45;
  inline const ::std::string& net_tcp() const;
  inline void set_net_tcp(const ::std::string& value);
  inline void set_net_tcp(const char* value);
  inline void set_net_tcp(const char* value, size_t size);
  inline ::std::string* mutable_net_tcp();
  inline ::std::string* release_net_tcp();
  
  // repeated .cetty.zurg.slave.DiskUsage disk_usage = 50;
  inline int disk_usage_size() const;
  inline void clear_disk_usage();
  static const int kDiskUsageFieldNumber = 50;
  inline const ::cetty::zurg::slave::DiskUsage& disk_usage(int index) const;
  inline ::cetty::zurg::slave::DiskUsage* mutable_disk_usage(int index);
  inline ::cetty::zurg::slave::DiskUsage* add_disk_usage();
  inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >&
      disk_usage() const;
  inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >*
      mutable_disk_usage();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.master.SlaveHeartbeat)
 private:
  inline void set_has_slave_name();
  inline void clear_has_slave_name();
  inline void set_has_send_time_us();
  inline void clear_has_send_time_us();
  inline void set_has_host_name();
  inline void clear_has_host_name();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();
  inline void set_has_slave_pid();
  inline void clear_has_slave_pid();
  inline void set_has_start_time_us();
  inline void clear_has_start_time_us();
  inline void set_has_slave_version();
  inline void clear_has_slave_version();
  inline void set_has_cpuinfo();
  inline void clear_has_cpuinfo();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_etc_mtab();
  inline void clear_has_etc_mtab();
  inline void set_has_sysctl();
  inline void clear_has_sysctl();
  inline void set_has_uname();
  inline void clear_has_uname();
  inline void set_has_meminfo();
  inline void clear_has_meminfo();
  inline void set_has_proc_stat();
  inline void clear_has_proc_stat();
  inline void set_has_loadavg();
  inline void clear_has_loadavg();
  inline void set_has_diskstats();
  inline void clear_has_diskstats();
  inline void set_has_net_dev();
  inline void clear_has_net_dev();
  inline void set_has_net_tcp();
  inline void clear_has_net_tcp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* slave_name_;
  ::google::protobuf::int64 send_time_us_;
  ::std::string* host_name_;
  ::google::protobuf::int32 listen_port_;
  ::google::protobuf::int32 slave_pid_;
  ::google::protobuf::int64 start_time_us_;
  ::std::string* slave_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> env_vars_;
  ::std::string* cpuinfo_;
  ::std::string* version_;
  ::std::string* etc_mtab_;
  ::std::string* sysctl_;
  ::cetty::zurg::master::SlaveHeartbeat_Uname* uname_;
  ::std::string* meminfo_;
  ::std::string* proc_stat_;
  ::std::string* loadavg_;
  ::std::string* diskstats_;
  ::std::string* net_dev_;
  ::std::string* net_tcp_;
  ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage > disk_usage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fmaster_2fmaster_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fmaster_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fmaster_2fmaster_2eproto();
  
  void InitAsDefaultInstance();
  static SlaveHeartbeat* default_instance_;
};
// ===================================================================

class MasterService_Stub;

typedef ::cetty::zurg::master::SlaveHeartbeat* SlaveHeartbeatPtr;
typedef ::cetty::zurg::master::SlaveHeartbeat const* ConstSlaveHeartbeatPtr;
typedef ::cetty::protobuf::service::Empty* EmptyPtr;
typedef ::cetty::service::ServiceFuture<EmptyPtr> slaveHeartbeatServiceFuture;
typedef boost::intrusive_ptr<slaveHeartbeatServiceFuture> slaveHeartbeatServiceFuturePtr;
typedef ::cetty::zurg::slave::ApplicationStatus* ApplicationStatusPtr;
typedef ::cetty::zurg::slave::ApplicationStatus const* ConstApplicationStatusPtr;
typedef ::cetty::protobuf::service::Empty* EmptyPtr;
typedef ::cetty::service::ServiceFuture<EmptyPtr> appStatusChangeServiceFuture;
typedef boost::intrusive_ptr<appStatusChangeServiceFuture> appStatusChangeServiceFuturePtr;

class MasterService : public ::cetty::protobuf::service::ProtobufService {
 protected:
  // This class should be treated as an abstract interface.
  inline MasterService() {};
 public:
  virtual ~MasterService();
  
  typedef MasterService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void slaveHeartbeat(const ConstSlaveHeartbeatPtr& request,
                       const EmptyPtr& response,
                       const DoneCallback& done);
  virtual void appStatusChange(const ConstApplicationStatusPtr& request,
                       const EmptyPtr& response,
                       const DoneCallback& done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  const ::cetty::protobuf::service::ConstMessagePtr& request,
                  const ::cetty::protobuf::service::MessagePtr& response,
                  const DoneCallback& done);
  
  const ::google::protobuf::Message* GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message* GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MasterService);
};

class MasterService_Stub : public MasterService {
 public:
  MasterService_Stub(const ::cetty::service::ClientServicePtr& service);
  ~MasterService_Stub();
  
  inline const ::cetty::service::ClientServicePtr& channel() {
      return channel_.getService();
  }
  
  // implements MasterService ------------------------------------------
  
  using MasterService::slaveHeartbeat;
  virtual void slaveHeartbeat(const ConstSlaveHeartbeatPtr& request,
                       const slaveHeartbeatServiceFuturePtr& future);
  using MasterService::appStatusChange;
  virtual void appStatusChange(const ConstApplicationStatusPtr& request,
                       const appStatusChangeServiceFuturePtr& future);
 private:
  cetty::protobuf::service::ProtobufClientServiceAdaptor channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MasterService_Stub);
};


// ===================================================================


// ===================================================================

// SlaveHeartbeat_Uname

// required string sys_name = 1;
inline bool SlaveHeartbeat_Uname::has_sys_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_sys_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveHeartbeat_Uname::clear_has_sys_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveHeartbeat_Uname::clear_sys_name() {
  if (sys_name_ != &::google::protobuf::internal::kEmptyString) {
    sys_name_->clear();
  }
  clear_has_sys_name();
}
inline const ::std::string& SlaveHeartbeat_Uname::sys_name() const {
  return *sys_name_;
}
inline void SlaveHeartbeat_Uname::set_sys_name(const ::std::string& value) {
  set_has_sys_name();
  if (sys_name_ == &::google::protobuf::internal::kEmptyString) {
    sys_name_ = new ::std::string;
  }
  sys_name_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_sys_name(const char* value) {
  set_has_sys_name();
  if (sys_name_ == &::google::protobuf::internal::kEmptyString) {
    sys_name_ = new ::std::string;
  }
  sys_name_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_sys_name(const char* value, size_t size) {
  set_has_sys_name();
  if (sys_name_ == &::google::protobuf::internal::kEmptyString) {
    sys_name_ = new ::std::string;
  }
  sys_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_sys_name() {
  set_has_sys_name();
  if (sys_name_ == &::google::protobuf::internal::kEmptyString) {
    sys_name_ = new ::std::string;
  }
  return sys_name_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_sys_name() {
  clear_has_sys_name();
  if (sys_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sys_name_;
    sys_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string node_name = 2;
inline bool SlaveHeartbeat_Uname::has_node_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_node_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveHeartbeat_Uname::clear_has_node_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveHeartbeat_Uname::clear_node_name() {
  if (node_name_ != &::google::protobuf::internal::kEmptyString) {
    node_name_->clear();
  }
  clear_has_node_name();
}
inline const ::std::string& SlaveHeartbeat_Uname::node_name() const {
  return *node_name_;
}
inline void SlaveHeartbeat_Uname::set_node_name(const ::std::string& value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_node_name(const char* value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_node_name(const char* value, size_t size) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_node_name() {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  return node_name_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_node_name() {
  clear_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_name_;
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string release = 3;
inline bool SlaveHeartbeat_Uname::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveHeartbeat_Uname::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveHeartbeat_Uname::clear_release() {
  if (release_ != &::google::protobuf::internal::kEmptyString) {
    release_->clear();
  }
  clear_has_release();
}
inline const ::std::string& SlaveHeartbeat_Uname::release() const {
  return *release_;
}
inline void SlaveHeartbeat_Uname::set_release(const ::std::string& value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  release_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_release(const char* value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  release_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_release(const char* value, size_t size) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  release_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_release() {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  return release_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_release() {
  clear_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_;
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string version = 4;
inline bool SlaveHeartbeat_Uname::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveHeartbeat_Uname::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveHeartbeat_Uname::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SlaveHeartbeat_Uname::version() const {
  return *version_;
}
inline void SlaveHeartbeat_Uname::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string machine = 5;
inline bool SlaveHeartbeat_Uname::has_machine() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_machine() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveHeartbeat_Uname::clear_has_machine() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveHeartbeat_Uname::clear_machine() {
  if (machine_ != &::google::protobuf::internal::kEmptyString) {
    machine_->clear();
  }
  clear_has_machine();
}
inline const ::std::string& SlaveHeartbeat_Uname::machine() const {
  return *machine_;
}
inline void SlaveHeartbeat_Uname::set_machine(const ::std::string& value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_machine(const char* value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_machine(const char* value, size_t size) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  machine_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_machine() {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  return machine_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_machine() {
  clear_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_;
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string domain_name = 6;
inline bool SlaveHeartbeat_Uname::has_domain_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_domain_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveHeartbeat_Uname::clear_has_domain_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveHeartbeat_Uname::clear_domain_name() {
  if (domain_name_ != &::google::protobuf::internal::kEmptyString) {
    domain_name_->clear();
  }
  clear_has_domain_name();
}
inline const ::std::string& SlaveHeartbeat_Uname::domain_name() const {
  return *domain_name_;
}
inline void SlaveHeartbeat_Uname::set_domain_name(const ::std::string& value) {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  domain_name_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_domain_name(const char* value) {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  domain_name_->assign(value);
}
inline void SlaveHeartbeat_Uname::set_domain_name(const char* value, size_t size) {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  domain_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_domain_name() {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  return domain_name_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_domain_name() {
  clear_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_name_;
    domain_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SlaveHeartbeat

// required string slave_name = 1;
inline bool SlaveHeartbeat::has_slave_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveHeartbeat::set_has_slave_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveHeartbeat::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveHeartbeat::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& SlaveHeartbeat::slave_name() const {
  return *slave_name_;
}
inline void SlaveHeartbeat::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveHeartbeat::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveHeartbeat::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* SlaveHeartbeat::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 send_time_us = 2;
inline bool SlaveHeartbeat::has_send_time_us() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveHeartbeat::set_has_send_time_us() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveHeartbeat::clear_has_send_time_us() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveHeartbeat::clear_send_time_us() {
  send_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_send_time_us();
}
inline ::google::protobuf::int64 SlaveHeartbeat::send_time_us() const {
  return send_time_us_;
}
inline void SlaveHeartbeat::set_send_time_us(::google::protobuf::int64 value) {
  set_has_send_time_us();
  send_time_us_ = value;
}

// optional string host_name = 20;
inline bool SlaveHeartbeat::has_host_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveHeartbeat::set_has_host_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveHeartbeat::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveHeartbeat::clear_host_name() {
  if (host_name_ != &::google::protobuf::internal::kEmptyString) {
    host_name_->clear();
  }
  clear_has_host_name();
}
inline const ::std::string& SlaveHeartbeat::host_name() const {
  return *host_name_;
}
inline void SlaveHeartbeat::set_host_name(const ::std::string& value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
}
inline void SlaveHeartbeat::set_host_name(const char* value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
}
inline void SlaveHeartbeat::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_host_name() {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  return host_name_;
}
inline ::std::string* SlaveHeartbeat::release_host_name() {
  clear_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_name_;
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 listen_port = 21;
inline bool SlaveHeartbeat::has_listen_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveHeartbeat::set_has_listen_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveHeartbeat::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveHeartbeat::clear_listen_port() {
  listen_port_ = 0;
  clear_has_listen_port();
}
inline ::google::protobuf::int32 SlaveHeartbeat::listen_port() const {
  return listen_port_;
}
inline void SlaveHeartbeat::set_listen_port(::google::protobuf::int32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// optional int32 slave_pid = 22;
inline bool SlaveHeartbeat::has_slave_pid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveHeartbeat::set_has_slave_pid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveHeartbeat::clear_has_slave_pid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveHeartbeat::clear_slave_pid() {
  slave_pid_ = 0;
  clear_has_slave_pid();
}
inline ::google::protobuf::int32 SlaveHeartbeat::slave_pid() const {
  return slave_pid_;
}
inline void SlaveHeartbeat::set_slave_pid(::google::protobuf::int32 value) {
  set_has_slave_pid();
  slave_pid_ = value;
}

// optional int64 start_time_us = 23;
inline bool SlaveHeartbeat::has_start_time_us() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveHeartbeat::set_has_start_time_us() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveHeartbeat::clear_has_start_time_us() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveHeartbeat::clear_start_time_us() {
  start_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_start_time_us();
}
inline ::google::protobuf::int64 SlaveHeartbeat::start_time_us() const {
  return start_time_us_;
}
inline void SlaveHeartbeat::set_start_time_us(::google::protobuf::int64 value) {
  set_has_start_time_us();
  start_time_us_ = value;
}

// optional string slave_version = 24;
inline bool SlaveHeartbeat::has_slave_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveHeartbeat::set_has_slave_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveHeartbeat::clear_has_slave_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveHeartbeat::clear_slave_version() {
  if (slave_version_ != &::google::protobuf::internal::kEmptyString) {
    slave_version_->clear();
  }
  clear_has_slave_version();
}
inline const ::std::string& SlaveHeartbeat::slave_version() const {
  return *slave_version_;
}
inline void SlaveHeartbeat::set_slave_version(const ::std::string& value) {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::kEmptyString) {
    slave_version_ = new ::std::string;
  }
  slave_version_->assign(value);
}
inline void SlaveHeartbeat::set_slave_version(const char* value) {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::kEmptyString) {
    slave_version_ = new ::std::string;
  }
  slave_version_->assign(value);
}
inline void SlaveHeartbeat::set_slave_version(const char* value, size_t size) {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::kEmptyString) {
    slave_version_ = new ::std::string;
  }
  slave_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_slave_version() {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::kEmptyString) {
    slave_version_ = new ::std::string;
  }
  return slave_version_;
}
inline ::std::string* SlaveHeartbeat::release_slave_version() {
  clear_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_version_;
    slave_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string env_vars = 25;
inline int SlaveHeartbeat::env_vars_size() const {
  return env_vars_.size();
}
inline void SlaveHeartbeat::clear_env_vars() {
  env_vars_.Clear();
}
inline const ::std::string& SlaveHeartbeat::env_vars(int index) const {
  return env_vars_.Get(index);
}
inline ::std::string* SlaveHeartbeat::mutable_env_vars(int index) {
  return env_vars_.Mutable(index);
}
inline void SlaveHeartbeat::set_env_vars(int index, const ::std::string& value) {
  env_vars_.Mutable(index)->assign(value);
}
inline void SlaveHeartbeat::set_env_vars(int index, const char* value) {
  env_vars_.Mutable(index)->assign(value);
}
inline void SlaveHeartbeat::set_env_vars(int index, const char* value, size_t size) {
  env_vars_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::add_env_vars() {
  return env_vars_.Add();
}
inline void SlaveHeartbeat::add_env_vars(const ::std::string& value) {
  env_vars_.Add()->assign(value);
}
inline void SlaveHeartbeat::add_env_vars(const char* value) {
  env_vars_.Add()->assign(value);
}
inline void SlaveHeartbeat::add_env_vars(const char* value, size_t size) {
  env_vars_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveHeartbeat::env_vars() const {
  return env_vars_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveHeartbeat::mutable_env_vars() {
  return &env_vars_;
}

// optional string cpuinfo = 30;
inline bool SlaveHeartbeat::has_cpuinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlaveHeartbeat::set_has_cpuinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlaveHeartbeat::clear_has_cpuinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlaveHeartbeat::clear_cpuinfo() {
  if (cpuinfo_ != &::google::protobuf::internal::kEmptyString) {
    cpuinfo_->clear();
  }
  clear_has_cpuinfo();
}
inline const ::std::string& SlaveHeartbeat::cpuinfo() const {
  return *cpuinfo_;
}
inline void SlaveHeartbeat::set_cpuinfo(const ::std::string& value) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(value);
}
inline void SlaveHeartbeat::set_cpuinfo(const char* value) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(value);
}
inline void SlaveHeartbeat::set_cpuinfo(const char* value, size_t size) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_cpuinfo() {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  return cpuinfo_;
}
inline ::std::string* SlaveHeartbeat::release_cpuinfo() {
  clear_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpuinfo_;
    cpuinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 31;
inline bool SlaveHeartbeat::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SlaveHeartbeat::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SlaveHeartbeat::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SlaveHeartbeat::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SlaveHeartbeat::version() const {
  return *version_;
}
inline void SlaveHeartbeat::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SlaveHeartbeat::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SlaveHeartbeat::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* SlaveHeartbeat::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string etc_mtab = 32;
inline bool SlaveHeartbeat::has_etc_mtab() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SlaveHeartbeat::set_has_etc_mtab() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SlaveHeartbeat::clear_has_etc_mtab() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SlaveHeartbeat::clear_etc_mtab() {
  if (etc_mtab_ != &::google::protobuf::internal::kEmptyString) {
    etc_mtab_->clear();
  }
  clear_has_etc_mtab();
}
inline const ::std::string& SlaveHeartbeat::etc_mtab() const {
  return *etc_mtab_;
}
inline void SlaveHeartbeat::set_etc_mtab(const ::std::string& value) {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::kEmptyString) {
    etc_mtab_ = new ::std::string;
  }
  etc_mtab_->assign(value);
}
inline void SlaveHeartbeat::set_etc_mtab(const char* value) {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::kEmptyString) {
    etc_mtab_ = new ::std::string;
  }
  etc_mtab_->assign(value);
}
inline void SlaveHeartbeat::set_etc_mtab(const char* value, size_t size) {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::kEmptyString) {
    etc_mtab_ = new ::std::string;
  }
  etc_mtab_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_etc_mtab() {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::kEmptyString) {
    etc_mtab_ = new ::std::string;
  }
  return etc_mtab_;
}
inline ::std::string* SlaveHeartbeat::release_etc_mtab() {
  clear_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etc_mtab_;
    etc_mtab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sysctl = 33;
inline bool SlaveHeartbeat::has_sysctl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SlaveHeartbeat::set_has_sysctl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SlaveHeartbeat::clear_has_sysctl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SlaveHeartbeat::clear_sysctl() {
  if (sysctl_ != &::google::protobuf::internal::kEmptyString) {
    sysctl_->clear();
  }
  clear_has_sysctl();
}
inline const ::std::string& SlaveHeartbeat::sysctl() const {
  return *sysctl_;
}
inline void SlaveHeartbeat::set_sysctl(const ::std::string& value) {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::kEmptyString) {
    sysctl_ = new ::std::string;
  }
  sysctl_->assign(value);
}
inline void SlaveHeartbeat::set_sysctl(const char* value) {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::kEmptyString) {
    sysctl_ = new ::std::string;
  }
  sysctl_->assign(value);
}
inline void SlaveHeartbeat::set_sysctl(const char* value, size_t size) {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::kEmptyString) {
    sysctl_ = new ::std::string;
  }
  sysctl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_sysctl() {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::kEmptyString) {
    sysctl_ = new ::std::string;
  }
  return sysctl_;
}
inline ::std::string* SlaveHeartbeat::release_sysctl() {
  clear_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysctl_;
    sysctl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .cetty.zurg.master.SlaveHeartbeat.Uname uname = 34;
inline bool SlaveHeartbeat::has_uname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SlaveHeartbeat::set_has_uname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SlaveHeartbeat::clear_has_uname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SlaveHeartbeat::clear_uname() {
  if (uname_ != NULL) uname_->::cetty::zurg::master::SlaveHeartbeat_Uname::Clear();
  clear_has_uname();
}
inline const ::cetty::zurg::master::SlaveHeartbeat_Uname& SlaveHeartbeat::uname() const {
  return uname_ != NULL ? *uname_ : *default_instance_->uname_;
}
inline ::cetty::zurg::master::SlaveHeartbeat_Uname* SlaveHeartbeat::mutable_uname() {
  set_has_uname();
  if (uname_ == NULL) uname_ = new ::cetty::zurg::master::SlaveHeartbeat_Uname;
  return uname_;
}
inline ::cetty::zurg::master::SlaveHeartbeat_Uname* SlaveHeartbeat::release_uname() {
  clear_has_uname();
  ::cetty::zurg::master::SlaveHeartbeat_Uname* temp = uname_;
  uname_ = NULL;
  return temp;
}

// optional string meminfo = 40;
inline bool SlaveHeartbeat::has_meminfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SlaveHeartbeat::set_has_meminfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SlaveHeartbeat::clear_has_meminfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SlaveHeartbeat::clear_meminfo() {
  if (meminfo_ != &::google::protobuf::internal::kEmptyString) {
    meminfo_->clear();
  }
  clear_has_meminfo();
}
inline const ::std::string& SlaveHeartbeat::meminfo() const {
  return *meminfo_;
}
inline void SlaveHeartbeat::set_meminfo(const ::std::string& value) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(value);
}
inline void SlaveHeartbeat::set_meminfo(const char* value) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(value);
}
inline void SlaveHeartbeat::set_meminfo(const char* value, size_t size) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_meminfo() {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  return meminfo_;
}
inline ::std::string* SlaveHeartbeat::release_meminfo() {
  clear_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meminfo_;
    meminfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proc_stat = 41;
inline bool SlaveHeartbeat::has_proc_stat() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SlaveHeartbeat::set_has_proc_stat() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SlaveHeartbeat::clear_has_proc_stat() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SlaveHeartbeat::clear_proc_stat() {
  if (proc_stat_ != &::google::protobuf::internal::kEmptyString) {
    proc_stat_->clear();
  }
  clear_has_proc_stat();
}
inline const ::std::string& SlaveHeartbeat::proc_stat() const {
  return *proc_stat_;
}
inline void SlaveHeartbeat::set_proc_stat(const ::std::string& value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void SlaveHeartbeat::set_proc_stat(const char* value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void SlaveHeartbeat::set_proc_stat(const char* value, size_t size) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_proc_stat() {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  return proc_stat_;
}
inline ::std::string* SlaveHeartbeat::release_proc_stat() {
  clear_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_stat_;
    proc_stat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string loadavg = 42;
inline bool SlaveHeartbeat::has_loadavg() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SlaveHeartbeat::set_has_loadavg() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SlaveHeartbeat::clear_has_loadavg() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SlaveHeartbeat::clear_loadavg() {
  if (loadavg_ != &::google::protobuf::internal::kEmptyString) {
    loadavg_->clear();
  }
  clear_has_loadavg();
}
inline const ::std::string& SlaveHeartbeat::loadavg() const {
  return *loadavg_;
}
inline void SlaveHeartbeat::set_loadavg(const ::std::string& value) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(value);
}
inline void SlaveHeartbeat::set_loadavg(const char* value) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(value);
}
inline void SlaveHeartbeat::set_loadavg(const char* value, size_t size) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_loadavg() {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  return loadavg_;
}
inline ::std::string* SlaveHeartbeat::release_loadavg() {
  clear_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loadavg_;
    loadavg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string diskstats = 43;
inline bool SlaveHeartbeat::has_diskstats() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SlaveHeartbeat::set_has_diskstats() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SlaveHeartbeat::clear_has_diskstats() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SlaveHeartbeat::clear_diskstats() {
  if (diskstats_ != &::google::protobuf::internal::kEmptyString) {
    diskstats_->clear();
  }
  clear_has_diskstats();
}
inline const ::std::string& SlaveHeartbeat::diskstats() const {
  return *diskstats_;
}
inline void SlaveHeartbeat::set_diskstats(const ::std::string& value) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(value);
}
inline void SlaveHeartbeat::set_diskstats(const char* value) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(value);
}
inline void SlaveHeartbeat::set_diskstats(const char* value, size_t size) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_diskstats() {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  return diskstats_;
}
inline ::std::string* SlaveHeartbeat::release_diskstats() {
  clear_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diskstats_;
    diskstats_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string net_dev = 44;
inline bool SlaveHeartbeat::has_net_dev() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SlaveHeartbeat::set_has_net_dev() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SlaveHeartbeat::clear_has_net_dev() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SlaveHeartbeat::clear_net_dev() {
  if (net_dev_ != &::google::protobuf::internal::kEmptyString) {
    net_dev_->clear();
  }
  clear_has_net_dev();
}
inline const ::std::string& SlaveHeartbeat::net_dev() const {
  return *net_dev_;
}
inline void SlaveHeartbeat::set_net_dev(const ::std::string& value) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(value);
}
inline void SlaveHeartbeat::set_net_dev(const char* value) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(value);
}
inline void SlaveHeartbeat::set_net_dev(const char* value, size_t size) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_net_dev() {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  return net_dev_;
}
inline ::std::string* SlaveHeartbeat::release_net_dev() {
  clear_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_dev_;
    net_dev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string net_tcp = 45;
inline bool SlaveHeartbeat::has_net_tcp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SlaveHeartbeat::set_has_net_tcp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SlaveHeartbeat::clear_has_net_tcp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SlaveHeartbeat::clear_net_tcp() {
  if (net_tcp_ != &::google::protobuf::internal::kEmptyString) {
    net_tcp_->clear();
  }
  clear_has_net_tcp();
}
inline const ::std::string& SlaveHeartbeat::net_tcp() const {
  return *net_tcp_;
}
inline void SlaveHeartbeat::set_net_tcp(const ::std::string& value) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(value);
}
inline void SlaveHeartbeat::set_net_tcp(const char* value) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(value);
}
inline void SlaveHeartbeat::set_net_tcp(const char* value, size_t size) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveHeartbeat::mutable_net_tcp() {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  return net_tcp_;
}
inline ::std::string* SlaveHeartbeat::release_net_tcp() {
  clear_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_tcp_;
    net_tcp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cetty.zurg.slave.DiskUsage disk_usage = 50;
inline int SlaveHeartbeat::disk_usage_size() const {
  return disk_usage_.size();
}
inline void SlaveHeartbeat::clear_disk_usage() {
  disk_usage_.Clear();
}
inline const ::cetty::zurg::slave::DiskUsage& SlaveHeartbeat::disk_usage(int index) const {
  return disk_usage_.Get(index);
}
inline ::cetty::zurg::slave::DiskUsage* SlaveHeartbeat::mutable_disk_usage(int index) {
  return disk_usage_.Mutable(index);
}
inline ::cetty::zurg::slave::DiskUsage* SlaveHeartbeat::add_disk_usage() {
  return disk_usage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >&
SlaveHeartbeat::disk_usage() const {
  return disk_usage_;
}
inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >*
SlaveHeartbeat::mutable_disk_usage() {
  return &disk_usage_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace master
}  // namespace zurg
}  // namespace cetty

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cetty_2fzurg_2fmaster_2fmaster_2eproto__INCLUDED


// Local Variables:
// mode: c++
// End:

