// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cetty/zurg/slave/slave.proto

#ifndef PROTOBUF_cetty_2fzurg_2fslave_2fslave_2eproto__INCLUDED
#define PROTOBUF_cetty_2fzurg_2fslave_2fslave_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <cetty/protobuf/service/ProtobufService.h>
#include <cetty/protobuf/service/ProtobufServiceFuture.h>
#include <cetty/protobuf/service/ProtobufServiceMessagePtr.h>
#include <cetty/protobuf/service/ProtobufClientServiceAdaptor.h>
// @@protoc_insertion_point(includes)

namespace cetty {
namespace zurg {
namespace slave {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();

class DiskUsage;
class GetHardwareRequest;
class GetHardwareResponse;
class GetFileContentRequest;
class GetFileContentResponse;
class GetFileChecksumRequest;
class GetFileChecksumResponse;
class ListProcessesRequest;
class ListProcessesResponse;
class ListProcessesResponse_Process;
class RunCommandRequest;
class RunCommandResponse;
class RunScriptRequest;
class ApplicationStatus;
class AddApplicationRequest;
class AddApplicationResponse;
class StartApplicationsRequest;
class StartApplicationsResponse;
class StopApplicationRequest;
class StopApplicationResponse;
class ListApplicationsRequest;
class ListApplicationsResponse;
class RemoveApplicationsRequest;
class RemoveApplicationsResponse;

enum ApplicationState {
  kUnknown = 0,
  kNewApp = 1,
  kRunning = 2,
  kExited = 3,
  kError = 4
};
bool ApplicationState_IsValid(int value);
const ApplicationState ApplicationState_MIN = kUnknown;
const ApplicationState ApplicationState_MAX = kError;
const int ApplicationState_ARRAYSIZE = ApplicationState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ApplicationState_descriptor();
inline const ::std::string& ApplicationState_Name(ApplicationState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ApplicationState_descriptor(), value);
}
inline bool ApplicationState_Parse(
    const ::std::string& name, ApplicationState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ApplicationState>(
    ApplicationState_descriptor(), name, value);
}
// ===================================================================

class DiskUsage : public ::google::protobuf::Message {
 public:
  DiskUsage();
  virtual ~DiskUsage();
  
  DiskUsage(const DiskUsage& from);
  
  inline DiskUsage& operator=(const DiskUsage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskUsage& default_instance();
  
  void Swap(DiskUsage* other);
  
  // implements Message ----------------------------------------------
  
  DiskUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskUsage& from);
  void MergeFrom(const DiskUsage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  
  // required string mount = 2;
  inline bool has_mount() const;
  inline void clear_mount();
  static const int kMountFieldNumber = 2;
  inline const ::std::string& mount() const;
  inline void set_mount(const ::std::string& value);
  inline void set_mount(const char* value);
  inline void set_mount(const char* value, size_t size);
  inline ::std::string* mutable_mount();
  inline ::std::string* release_mount();
  
  // required int32 block_size = 3;
  inline bool has_block_size() const;
  inline void clear_block_size();
  static const int kBlockSizeFieldNumber = 3;
  inline ::google::protobuf::int32 block_size() const;
  inline void set_block_size(::google::protobuf::int32 value);
  
  // required int64 blocks_all = 4;
  inline bool has_blocks_all() const;
  inline void clear_blocks_all();
  static const int kBlocksAllFieldNumber = 4;
  inline ::google::protobuf::int64 blocks_all() const;
  inline void set_blocks_all(::google::protobuf::int64 value);
  
  // required int64 blocks_free = 5;
  inline bool has_blocks_free() const;
  inline void clear_blocks_free();
  static const int kBlocksFreeFieldNumber = 5;
  inline ::google::protobuf::int64 blocks_free() const;
  inline void set_blocks_free(::google::protobuf::int64 value);
  
  // required int64 blocks_avail = 6;
  inline bool has_blocks_avail() const;
  inline void clear_blocks_avail();
  static const int kBlocksAvailFieldNumber = 6;
  inline ::google::protobuf::int64 blocks_avail() const;
  inline void set_blocks_avail(::google::protobuf::int64 value);
  
  // required int64 inodes_all = 7;
  inline bool has_inodes_all() const;
  inline void clear_inodes_all();
  static const int kInodesAllFieldNumber = 7;
  inline ::google::protobuf::int64 inodes_all() const;
  inline void set_inodes_all(::google::protobuf::int64 value);
  
  // required int64 inodes_free = 8;
  inline bool has_inodes_free() const;
  inline void clear_inodes_free();
  static const int kInodesFreeFieldNumber = 8;
  inline ::google::protobuf::int64 inodes_free() const;
  inline void set_inodes_free(::google::protobuf::int64 value);
  
  // required int64 inodes_avail = 9;
  inline bool has_inodes_avail() const;
  inline void clear_inodes_avail();
  static const int kInodesAvailFieldNumber = 9;
  inline ::google::protobuf::int64 inodes_avail() const;
  inline void set_inodes_avail(::google::protobuf::int64 value);
  
  // required uint64 fsid = 10;
  inline bool has_fsid() const;
  inline void clear_fsid();
  static const int kFsidFieldNumber = 10;
  inline ::google::protobuf::uint64 fsid() const;
  inline void set_fsid(::google::protobuf::uint64 value);
  
  // required uint64 flag = 11;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 11;
  inline ::google::protobuf::uint64 flag() const;
  inline void set_flag(::google::protobuf::uint64 value);
  
  // required uint64 namemax = 12;
  inline bool has_namemax() const;
  inline void clear_namemax();
  static const int kNamemaxFieldNumber = 12;
  inline ::google::protobuf::uint64 namemax() const;
  inline void set_namemax(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.DiskUsage)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_mount();
  inline void clear_has_mount();
  inline void set_has_block_size();
  inline void clear_has_block_size();
  inline void set_has_blocks_all();
  inline void clear_has_blocks_all();
  inline void set_has_blocks_free();
  inline void clear_has_blocks_free();
  inline void set_has_blocks_avail();
  inline void clear_has_blocks_avail();
  inline void set_has_inodes_all();
  inline void clear_has_inodes_all();
  inline void set_has_inodes_free();
  inline void clear_has_inodes_free();
  inline void set_has_inodes_avail();
  inline void clear_has_inodes_avail();
  inline void set_has_fsid();
  inline void clear_has_fsid();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_namemax();
  inline void clear_has_namemax();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* device_;
  ::std::string* mount_;
  ::google::protobuf::int64 blocks_all_;
  ::google::protobuf::int64 blocks_free_;
  ::google::protobuf::int64 blocks_avail_;
  ::google::protobuf::int64 inodes_all_;
  ::google::protobuf::int64 inodes_free_;
  ::google::protobuf::int64 inodes_avail_;
  ::google::protobuf::uint64 fsid_;
  ::google::protobuf::uint64 flag_;
  ::google::protobuf::uint64 namemax_;
  ::google::protobuf::int32 block_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static DiskUsage* default_instance_;
};
// -------------------------------------------------------------------

class GetHardwareRequest : public ::google::protobuf::Message {
 public:
  GetHardwareRequest();
  virtual ~GetHardwareRequest();
  
  GetHardwareRequest(const GetHardwareRequest& from);
  
  inline GetHardwareRequest& operator=(const GetHardwareRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHardwareRequest& default_instance();
  
  void Swap(GetHardwareRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetHardwareRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetHardwareRequest& from);
  void MergeFrom(const GetHardwareRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 lshw = 1 [default = 0];
  inline bool has_lshw() const;
  inline void clear_lshw();
  static const int kLshwFieldNumber = 1;
  inline ::google::protobuf::int32 lshw() const;
  inline void set_lshw(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.GetHardwareRequest)
 private:
  inline void set_has_lshw();
  inline void clear_has_lshw();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 lshw_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static GetHardwareRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetHardwareResponse : public ::google::protobuf::Message {
 public:
  GetHardwareResponse();
  virtual ~GetHardwareResponse();
  
  GetHardwareResponse(const GetHardwareResponse& from);
  
  inline GetHardwareResponse& operator=(const GetHardwareResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHardwareResponse& default_instance();
  
  void Swap(GetHardwareResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetHardwareResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetHardwareResponse& from);
  void MergeFrom(const GetHardwareResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string lspci = 1;
  inline bool has_lspci() const;
  inline void clear_lspci();
  static const int kLspciFieldNumber = 1;
  inline const ::std::string& lspci() const;
  inline void set_lspci(const ::std::string& value);
  inline void set_lspci(const char* value);
  inline void set_lspci(const char* value, size_t size);
  inline ::std::string* mutable_lspci();
  inline ::std::string* release_lspci();
  
  // optional string lscpu = 2;
  inline bool has_lscpu() const;
  inline void clear_lscpu();
  static const int kLscpuFieldNumber = 2;
  inline const ::std::string& lscpu() const;
  inline void set_lscpu(const ::std::string& value);
  inline void set_lscpu(const char* value);
  inline void set_lscpu(const char* value, size_t size);
  inline ::std::string* mutable_lscpu();
  inline ::std::string* release_lscpu();
  
  // optional string lshw = 3;
  inline bool has_lshw() const;
  inline void clear_lshw();
  static const int kLshwFieldNumber = 3;
  inline const ::std::string& lshw() const;
  inline void set_lshw(const ::std::string& value);
  inline void set_lshw(const char* value);
  inline void set_lshw(const char* value, size_t size);
  inline ::std::string* mutable_lshw();
  inline ::std::string* release_lshw();
  
  // optional string ifconfig = 4;
  inline bool has_ifconfig() const;
  inline void clear_ifconfig();
  static const int kIfconfigFieldNumber = 4;
  inline const ::std::string& ifconfig() const;
  inline void set_ifconfig(const ::std::string& value);
  inline void set_ifconfig(const char* value);
  inline void set_ifconfig(const char* value, size_t size);
  inline ::std::string* mutable_ifconfig();
  inline ::std::string* release_ifconfig();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.GetHardwareResponse)
 private:
  inline void set_has_lspci();
  inline void clear_has_lspci();
  inline void set_has_lscpu();
  inline void clear_has_lscpu();
  inline void set_has_lshw();
  inline void clear_has_lshw();
  inline void set_has_ifconfig();
  inline void clear_has_ifconfig();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* lspci_;
  ::std::string* lscpu_;
  ::std::string* lshw_;
  ::std::string* ifconfig_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static GetHardwareResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetFileContentRequest : public ::google::protobuf::Message {
 public:
  GetFileContentRequest();
  virtual ~GetFileContentRequest();
  
  GetFileContentRequest(const GetFileContentRequest& from);
  
  inline GetFileContentRequest& operator=(const GetFileContentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileContentRequest& default_instance();
  
  void Swap(GetFileContentRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetFileContentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileContentRequest& from);
  void MergeFrom(const GetFileContentRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // optional int32 max_size = 2 [default = 1048576];
  inline bool has_max_size() const;
  inline void clear_max_size();
  static const int kMaxSizeFieldNumber = 2;
  inline ::google::protobuf::int32 max_size() const;
  inline void set_max_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.GetFileContentRequest)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_max_size();
  inline void clear_has_max_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* file_name_;
  ::google::protobuf::int32 max_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static GetFileContentRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFileContentResponse : public ::google::protobuf::Message {
 public:
  GetFileContentResponse();
  virtual ~GetFileContentResponse();
  
  GetFileContentResponse(const GetFileContentResponse& from);
  
  inline GetFileContentResponse& operator=(const GetFileContentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileContentResponse& default_instance();
  
  void Swap(GetFileContentResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetFileContentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileContentResponse& from);
  void MergeFrom(const GetFileContentResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);
  
  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // optional int64 file_size = 3;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  inline ::google::protobuf::int64 file_size() const;
  inline void set_file_size(::google::protobuf::int64 value);
  
  // optional int64 modify_time = 4;
  inline bool has_modify_time() const;
  inline void clear_modify_time();
  static const int kModifyTimeFieldNumber = 4;
  inline ::google::protobuf::int64 modify_time() const;
  inline void set_modify_time(::google::protobuf::int64 value);
  
  // optional int64 create_time = 5;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 create_time() const;
  inline void set_create_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.GetFileContentResponse)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_modify_time();
  inline void clear_has_modify_time();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* content_;
  ::google::protobuf::int64 file_size_;
  ::google::protobuf::int64 modify_time_;
  ::google::protobuf::int64 create_time_;
  ::google::protobuf::int32 error_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static GetFileContentResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetFileChecksumRequest : public ::google::protobuf::Message {
 public:
  GetFileChecksumRequest();
  virtual ~GetFileChecksumRequest();
  
  GetFileChecksumRequest(const GetFileChecksumRequest& from);
  
  inline GetFileChecksumRequest& operator=(const GetFileChecksumRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileChecksumRequest& default_instance();
  
  void Swap(GetFileChecksumRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetFileChecksumRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileChecksumRequest& from);
  void MergeFrom(const GetFileChecksumRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string files = 1;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 1;
  inline const ::std::string& files(int index) const;
  inline ::std::string* mutable_files(int index);
  inline void set_files(int index, const ::std::string& value);
  inline void set_files(int index, const char* value);
  inline void set_files(int index, const char* value, size_t size);
  inline ::std::string* add_files();
  inline void add_files(const ::std::string& value);
  inline void add_files(const char* value);
  inline void add_files(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& files() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_files();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.GetFileChecksumRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> files_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static GetFileChecksumRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFileChecksumResponse : public ::google::protobuf::Message {
 public:
  GetFileChecksumResponse();
  virtual ~GetFileChecksumResponse();
  
  GetFileChecksumResponse(const GetFileChecksumResponse& from);
  
  inline GetFileChecksumResponse& operator=(const GetFileChecksumResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileChecksumResponse& default_instance();
  
  void Swap(GetFileChecksumResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetFileChecksumResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileChecksumResponse& from);
  void MergeFrom(const GetFileChecksumResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string md5sums = 1;
  inline int md5sums_size() const;
  inline void clear_md5sums();
  static const int kMd5SumsFieldNumber = 1;
  inline const ::std::string& md5sums(int index) const;
  inline ::std::string* mutable_md5sums(int index);
  inline void set_md5sums(int index, const ::std::string& value);
  inline void set_md5sums(int index, const char* value);
  inline void set_md5sums(int index, const char* value, size_t size);
  inline ::std::string* add_md5sums();
  inline void add_md5sums(const ::std::string& value);
  inline void add_md5sums(const char* value);
  inline void add_md5sums(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& md5sums() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_md5sums();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.GetFileChecksumResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> md5sums_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static GetFileChecksumResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListProcessesRequest : public ::google::protobuf::Message {
 public:
  ListProcessesRequest();
  virtual ~ListProcessesRequest();
  
  ListProcessesRequest(const ListProcessesRequest& from);
  
  inline ListProcessesRequest& operator=(const ListProcessesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListProcessesRequest& default_instance();
  
  void Swap(ListProcessesRequest* other);
  
  // implements Message ----------------------------------------------
  
  ListProcessesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListProcessesRequest& from);
  void MergeFrom(const ListProcessesRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string include_users = 1;
  inline int include_users_size() const;
  inline void clear_include_users();
  static const int kIncludeUsersFieldNumber = 1;
  inline const ::std::string& include_users(int index) const;
  inline ::std::string* mutable_include_users(int index);
  inline void set_include_users(int index, const ::std::string& value);
  inline void set_include_users(int index, const char* value);
  inline void set_include_users(int index, const char* value, size_t size);
  inline ::std::string* add_include_users();
  inline void add_include_users(const ::std::string& value);
  inline void add_include_users(const char* value);
  inline void add_include_users(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& include_users() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_include_users();
  
  // repeated string exclude_users = 2;
  inline int exclude_users_size() const;
  inline void clear_exclude_users();
  static const int kExcludeUsersFieldNumber = 2;
  inline const ::std::string& exclude_users(int index) const;
  inline ::std::string* mutable_exclude_users(int index);
  inline void set_exclude_users(int index, const ::std::string& value);
  inline void set_exclude_users(int index, const char* value);
  inline void set_exclude_users(int index, const char* value, size_t size);
  inline ::std::string* add_exclude_users();
  inline void add_exclude_users(const ::std::string& value);
  inline void add_exclude_users(const char* value);
  inline void add_exclude_users(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exclude_users() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exclude_users();
  
  // optional bool get_load = 3 [default = false];
  inline bool has_get_load() const;
  inline void clear_get_load();
  static const int kGetLoadFieldNumber = 3;
  inline bool get_load() const;
  inline void set_get_load(bool value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.ListProcessesRequest)
 private:
  inline void set_has_get_load();
  inline void clear_has_get_load();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> include_users_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exclude_users_;
  bool get_load_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static ListProcessesRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListProcessesResponse_Process : public ::google::protobuf::Message {
 public:
  ListProcessesResponse_Process();
  virtual ~ListProcessesResponse_Process();
  
  ListProcessesResponse_Process(const ListProcessesResponse_Process& from);
  
  inline ListProcessesResponse_Process& operator=(const ListProcessesResponse_Process& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListProcessesResponse_Process& default_instance();
  
  void Swap(ListProcessesResponse_Process* other);
  
  // implements Message ----------------------------------------------
  
  ListProcessesResponse_Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListProcessesResponse_Process& from);
  void MergeFrom(const ListProcessesResponse_Process& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);
  
  // required string proc_stat = 2;
  inline bool has_proc_stat() const;
  inline void clear_proc_stat();
  static const int kProcStatFieldNumber = 2;
  inline const ::std::string& proc_stat() const;
  inline void set_proc_stat(const ::std::string& value);
  inline void set_proc_stat(const char* value);
  inline void set_proc_stat(const char* value, size_t size);
  inline ::std::string* mutable_proc_stat();
  inline ::std::string* release_proc_stat();
  
  // required string proc_status = 3;
  inline bool has_proc_status() const;
  inline void clear_proc_status();
  static const int kProcStatusFieldNumber = 3;
  inline const ::std::string& proc_status() const;
  inline void set_proc_status(const ::std::string& value);
  inline void set_proc_status(const char* value);
  inline void set_proc_status(const char* value, size_t size);
  inline ::std::string* mutable_proc_status();
  inline ::std::string* release_proc_status();
  
  // optional string cmdline = 4;
  inline bool has_cmdline() const;
  inline void clear_cmdline();
  static const int kCmdlineFieldNumber = 4;
  inline const ::std::string& cmdline() const;
  inline void set_cmdline(const ::std::string& value);
  inline void set_cmdline(const char* value);
  inline void set_cmdline(const char* value, size_t size);
  inline ::std::string* mutable_cmdline();
  inline ::std::string* release_cmdline();
  
  // optional string exe_file = 5;
  inline bool has_exe_file() const;
  inline void clear_exe_file();
  static const int kExeFileFieldNumber = 5;
  inline const ::std::string& exe_file() const;
  inline void set_exe_file(const ::std::string& value);
  inline void set_exe_file(const char* value);
  inline void set_exe_file(const char* value, size_t size);
  inline ::std::string* mutable_exe_file();
  inline ::std::string* release_exe_file();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.ListProcessesResponse.Process)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_proc_stat();
  inline void clear_has_proc_stat();
  inline void set_has_proc_status();
  inline void clear_has_proc_status();
  inline void set_has_cmdline();
  inline void clear_has_cmdline();
  inline void set_has_exe_file();
  inline void clear_has_exe_file();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* proc_stat_;
  ::std::string* proc_status_;
  ::std::string* cmdline_;
  ::std::string* exe_file_;
  ::google::protobuf::int32 pid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static ListProcessesResponse_Process* default_instance_;
};
// -------------------------------------------------------------------

class ListProcessesResponse : public ::google::protobuf::Message {
 public:
  ListProcessesResponse();
  virtual ~ListProcessesResponse();
  
  ListProcessesResponse(const ListProcessesResponse& from);
  
  inline ListProcessesResponse& operator=(const ListProcessesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListProcessesResponse& default_instance();
  
  void Swap(ListProcessesResponse* other);
  
  // implements Message ----------------------------------------------
  
  ListProcessesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListProcessesResponse& from);
  void MergeFrom(const ListProcessesResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ListProcessesResponse_Process Process;
  
  // accessors -------------------------------------------------------
  
  // repeated .cetty.zurg.slave.ListProcessesResponse.Process processes = 1;
  inline int processes_size() const;
  inline void clear_processes();
  static const int kProcessesFieldNumber = 1;
  inline const ::cetty::zurg::slave::ListProcessesResponse_Process& processes(int index) const;
  inline ::cetty::zurg::slave::ListProcessesResponse_Process* mutable_processes(int index);
  inline ::cetty::zurg::slave::ListProcessesResponse_Process* add_processes();
  inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ListProcessesResponse_Process >&
      processes() const;
  inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ListProcessesResponse_Process >*
      mutable_processes();
  
  // optional string meminfo = 2;
  inline bool has_meminfo() const;
  inline void clear_meminfo();
  static const int kMeminfoFieldNumber = 2;
  inline const ::std::string& meminfo() const;
  inline void set_meminfo(const ::std::string& value);
  inline void set_meminfo(const char* value);
  inline void set_meminfo(const char* value, size_t size);
  inline ::std::string* mutable_meminfo();
  inline ::std::string* release_meminfo();
  
  // optional string proc_stat = 3;
  inline bool has_proc_stat() const;
  inline void clear_proc_stat();
  static const int kProcStatFieldNumber = 3;
  inline const ::std::string& proc_stat() const;
  inline void set_proc_stat(const ::std::string& value);
  inline void set_proc_stat(const char* value);
  inline void set_proc_stat(const char* value, size_t size);
  inline ::std::string* mutable_proc_stat();
  inline ::std::string* release_proc_stat();
  
  // optional string loadavg = 4;
  inline bool has_loadavg() const;
  inline void clear_loadavg();
  static const int kLoadavgFieldNumber = 4;
  inline const ::std::string& loadavg() const;
  inline void set_loadavg(const ::std::string& value);
  inline void set_loadavg(const char* value);
  inline void set_loadavg(const char* value, size_t size);
  inline ::std::string* mutable_loadavg();
  inline ::std::string* release_loadavg();
  
  // optional string diskstats = 5;
  inline bool has_diskstats() const;
  inline void clear_diskstats();
  static const int kDiskstatsFieldNumber = 5;
  inline const ::std::string& diskstats() const;
  inline void set_diskstats(const ::std::string& value);
  inline void set_diskstats(const char* value);
  inline void set_diskstats(const char* value, size_t size);
  inline ::std::string* mutable_diskstats();
  inline ::std::string* release_diskstats();
  
  // optional string net_dev = 6;
  inline bool has_net_dev() const;
  inline void clear_net_dev();
  static const int kNetDevFieldNumber = 6;
  inline const ::std::string& net_dev() const;
  inline void set_net_dev(const ::std::string& value);
  inline void set_net_dev(const char* value);
  inline void set_net_dev(const char* value, size_t size);
  inline ::std::string* mutable_net_dev();
  inline ::std::string* release_net_dev();
  
  // optional string net_tcp = 7;
  inline bool has_net_tcp() const;
  inline void clear_net_tcp();
  static const int kNetTcpFieldNumber = 7;
  inline const ::std::string& net_tcp() const;
  inline void set_net_tcp(const ::std::string& value);
  inline void set_net_tcp(const char* value);
  inline void set_net_tcp(const char* value, size_t size);
  inline ::std::string* mutable_net_tcp();
  inline ::std::string* release_net_tcp();
  
  // repeated .cetty.zurg.slave.DiskUsage disk_usage = 8;
  inline int disk_usage_size() const;
  inline void clear_disk_usage();
  static const int kDiskUsageFieldNumber = 8;
  inline const ::cetty::zurg::slave::DiskUsage& disk_usage(int index) const;
  inline ::cetty::zurg::slave::DiskUsage* mutable_disk_usage(int index);
  inline ::cetty::zurg::slave::DiskUsage* add_disk_usage();
  inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >&
      disk_usage() const;
  inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >*
      mutable_disk_usage();
  
  // optional string version = 9;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 9;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string cpuinfo = 10;
  inline bool has_cpuinfo() const;
  inline void clear_cpuinfo();
  static const int kCpuinfoFieldNumber = 10;
  inline const ::std::string& cpuinfo() const;
  inline void set_cpuinfo(const ::std::string& value);
  inline void set_cpuinfo(const char* value);
  inline void set_cpuinfo(const char* value, size_t size);
  inline ::std::string* mutable_cpuinfo();
  inline ::std::string* release_cpuinfo();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.ListProcessesResponse)
 private:
  inline void set_has_meminfo();
  inline void clear_has_meminfo();
  inline void set_has_proc_stat();
  inline void clear_has_proc_stat();
  inline void set_has_loadavg();
  inline void clear_has_loadavg();
  inline void set_has_diskstats();
  inline void clear_has_diskstats();
  inline void set_has_net_dev();
  inline void clear_has_net_dev();
  inline void set_has_net_tcp();
  inline void clear_has_net_tcp();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cpuinfo();
  inline void clear_has_cpuinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ListProcessesResponse_Process > processes_;
  ::std::string* meminfo_;
  ::std::string* proc_stat_;
  ::std::string* loadavg_;
  ::std::string* diskstats_;
  ::std::string* net_dev_;
  ::std::string* net_tcp_;
  ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage > disk_usage_;
  ::std::string* version_;
  ::std::string* cpuinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static ListProcessesResponse* default_instance_;
};
// -------------------------------------------------------------------

class RunCommandRequest : public ::google::protobuf::Message {
 public:
  RunCommandRequest();
  virtual ~RunCommandRequest();
  
  RunCommandRequest(const RunCommandRequest& from);
  
  inline RunCommandRequest& operator=(const RunCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunCommandRequest& default_instance();
  
  void Swap(RunCommandRequest* other);
  
  // implements Message ----------------------------------------------
  
  RunCommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunCommandRequest& from);
  void MergeFrom(const RunCommandRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  
  // optional string cwd = 2 [default = "/tmp"];
  inline bool has_cwd() const;
  inline void clear_cwd();
  static const int kCwdFieldNumber = 2;
  inline const ::std::string& cwd() const;
  inline void set_cwd(const ::std::string& value);
  inline void set_cwd(const char* value);
  inline void set_cwd(const char* value, size_t size);
  inline ::std::string* mutable_cwd();
  inline ::std::string* release_cwd();
  
  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();
  
  // repeated string envs = 4;
  inline int envs_size() const;
  inline void clear_envs();
  static const int kEnvsFieldNumber = 4;
  inline const ::std::string& envs(int index) const;
  inline ::std::string* mutable_envs(int index);
  inline void set_envs(int index, const ::std::string& value);
  inline void set_envs(int index, const char* value);
  inline void set_envs(int index, const char* value, size_t size);
  inline ::std::string* add_envs();
  inline void add_envs(const ::std::string& value);
  inline void add_envs(const char* value);
  inline void add_envs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& envs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_envs();
  
  // optional bool envs_only = 5 [default = false];
  inline bool has_envs_only() const;
  inline void clear_envs_only();
  static const int kEnvsOnlyFieldNumber = 5;
  inline bool envs_only() const;
  inline void set_envs_only(bool value);
  
  // optional int32 max_stdout = 6 [default = 1048576];
  inline bool has_max_stdout() const;
  inline void clear_max_stdout();
  static const int kMaxStdoutFieldNumber = 6;
  inline ::google::protobuf::int32 max_stdout() const;
  inline void set_max_stdout(::google::protobuf::int32 value);
  
  // optional int32 max_stderr = 7 [default = 1048576];
  inline bool has_max_stderr() const;
  inline void clear_max_stderr();
  static const int kMaxStderrFieldNumber = 7;
  inline ::google::protobuf::int32 max_stderr() const;
  inline void set_max_stderr(::google::protobuf::int32 value);
  
  // optional int32 timeout = 8 [default = 3000];
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // optional int32 max_memory_mb = 9 [default = 32768];
  inline bool has_max_memory_mb() const;
  inline void clear_max_memory_mb();
  static const int kMaxMemoryMbFieldNumber = 9;
  inline ::google::protobuf::int32 max_memory_mb() const;
  inline void set_max_memory_mb(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.RunCommandRequest)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_cwd();
  inline void clear_has_cwd();
  inline void set_has_envs_only();
  inline void clear_has_envs_only();
  inline void set_has_max_stdout();
  inline void clear_has_max_stdout();
  inline void set_has_max_stderr();
  inline void clear_has_max_stderr();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_max_memory_mb();
  inline void clear_has_max_memory_mb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* command_;
  ::std::string* cwd_;
  static const ::std::string _default_cwd_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::std::string> envs_;
  bool envs_only_;
  ::google::protobuf::int32 max_stdout_;
  ::google::protobuf::int32 max_stderr_;
  ::google::protobuf::int32 timeout_;
  ::google::protobuf::int32 max_memory_mb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static RunCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class RunCommandResponse : public ::google::protobuf::Message {
 public:
  RunCommandResponse();
  virtual ~RunCommandResponse();
  
  RunCommandResponse(const RunCommandResponse& from);
  
  inline RunCommandResponse& operator=(const RunCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunCommandResponse& default_instance();
  
  void Swap(RunCommandResponse* other);
  
  // implements Message ----------------------------------------------
  
  RunCommandResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunCommandResponse& from);
  void MergeFrom(const RunCommandResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);
  
  // optional int32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);
  
  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional bytes std_output = 4;
  inline bool has_std_output() const;
  inline void clear_std_output();
  static const int kStdOutputFieldNumber = 4;
  inline const ::std::string& std_output() const;
  inline void set_std_output(const ::std::string& value);
  inline void set_std_output(const char* value);
  inline void set_std_output(const void* value, size_t size);
  inline ::std::string* mutable_std_output();
  inline ::std::string* release_std_output();
  
  // optional bytes std_error = 5;
  inline bool has_std_error() const;
  inline void clear_std_error();
  static const int kStdErrorFieldNumber = 5;
  inline const ::std::string& std_error() const;
  inline void set_std_error(const ::std::string& value);
  inline void set_std_error(const char* value);
  inline void set_std_error(const void* value, size_t size);
  inline ::std::string* mutable_std_error();
  inline ::std::string* release_std_error();
  
  // optional string executable_file = 6;
  inline bool has_executable_file() const;
  inline void clear_executable_file();
  static const int kExecutableFileFieldNumber = 6;
  inline const ::std::string& executable_file() const;
  inline void set_executable_file(const ::std::string& value);
  inline void set_executable_file(const char* value);
  inline void set_executable_file(const char* value, size_t size);
  inline ::std::string* mutable_executable_file();
  inline ::std::string* release_executable_file();
  
  // optional int64 start_time_us = 16;
  inline bool has_start_time_us() const;
  inline void clear_start_time_us();
  static const int kStartTimeUsFieldNumber = 16;
  inline ::google::protobuf::int64 start_time_us() const;
  inline void set_start_time_us(::google::protobuf::int64 value);
  
  // optional int64 finish_time_us = 17;
  inline bool has_finish_time_us() const;
  inline void clear_finish_time_us();
  static const int kFinishTimeUsFieldNumber = 17;
  inline ::google::protobuf::int64 finish_time_us() const;
  inline void set_finish_time_us(::google::protobuf::int64 value);
  
  // optional float user_time = 18;
  inline bool has_user_time() const;
  inline void clear_user_time();
  static const int kUserTimeFieldNumber = 18;
  inline float user_time() const;
  inline void set_user_time(float value);
  
  // optional float system_time = 19;
  inline bool has_system_time() const;
  inline void clear_system_time();
  static const int kSystemTimeFieldNumber = 19;
  inline float system_time() const;
  inline void set_system_time(float value);
  
  // optional int64 memory_maxrss_kb = 20;
  inline bool has_memory_maxrss_kb() const;
  inline void clear_memory_maxrss_kb();
  static const int kMemoryMaxrssKbFieldNumber = 20;
  inline ::google::protobuf::int64 memory_maxrss_kb() const;
  inline void set_memory_maxrss_kb(::google::protobuf::int64 value);
  
  // optional int32 exit_status = 30 [default = 0];
  inline bool has_exit_status() const;
  inline void clear_exit_status();
  static const int kExitStatusFieldNumber = 30;
  inline ::google::protobuf::int32 exit_status() const;
  inline void set_exit_status(::google::protobuf::int32 value);
  
  // optional int32 signaled = 31 [default = 0];
  inline bool has_signaled() const;
  inline void clear_signaled();
  static const int kSignaledFieldNumber = 31;
  inline ::google::protobuf::int32 signaled() const;
  inline void set_signaled(::google::protobuf::int32 value);
  
  // optional bool coredump = 32 [default = false];
  inline bool has_coredump() const;
  inline void clear_coredump();
  static const int kCoredumpFieldNumber = 32;
  inline bool coredump() const;
  inline void set_coredump(bool value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.RunCommandResponse)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_std_output();
  inline void clear_has_std_output();
  inline void set_has_std_error();
  inline void clear_has_std_error();
  inline void set_has_executable_file();
  inline void clear_has_executable_file();
  inline void set_has_start_time_us();
  inline void clear_has_start_time_us();
  inline void set_has_finish_time_us();
  inline void clear_has_finish_time_us();
  inline void set_has_user_time();
  inline void clear_has_user_time();
  inline void set_has_system_time();
  inline void clear_has_system_time();
  inline void set_has_memory_maxrss_kb();
  inline void clear_has_memory_maxrss_kb();
  inline void set_has_exit_status();
  inline void clear_has_exit_status();
  inline void set_has_signaled();
  inline void clear_has_signaled();
  inline void set_has_coredump();
  inline void clear_has_coredump();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 error_code_;
  ::google::protobuf::int32 pid_;
  ::std::string* std_output_;
  ::std::string* std_error_;
  ::std::string* executable_file_;
  ::google::protobuf::int32 status_;
  float user_time_;
  ::google::protobuf::int64 start_time_us_;
  ::google::protobuf::int64 finish_time_us_;
  ::google::protobuf::int64 memory_maxrss_kb_;
  float system_time_;
  ::google::protobuf::int32 exit_status_;
  ::google::protobuf::int32 signaled_;
  bool coredump_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static RunCommandResponse* default_instance_;
};
// -------------------------------------------------------------------

class RunScriptRequest : public ::google::protobuf::Message {
 public:
  RunScriptRequest();
  virtual ~RunScriptRequest();
  
  RunScriptRequest(const RunScriptRequest& from);
  
  inline RunScriptRequest& operator=(const RunScriptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunScriptRequest& default_instance();
  
  void Swap(RunScriptRequest* other);
  
  // implements Message ----------------------------------------------
  
  RunScriptRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunScriptRequest& from);
  void MergeFrom(const RunScriptRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes script = 1;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 1;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // optional string cwd = 2 [default = "/tmp"];
  inline bool has_cwd() const;
  inline void clear_cwd();
  static const int kCwdFieldNumber = 2;
  inline const ::std::string& cwd() const;
  inline void set_cwd(const ::std::string& value);
  inline void set_cwd(const char* value);
  inline void set_cwd(const char* value, size_t size);
  inline ::std::string* mutable_cwd();
  inline ::std::string* release_cwd();
  
  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();
  
  // repeated string envs = 4;
  inline int envs_size() const;
  inline void clear_envs();
  static const int kEnvsFieldNumber = 4;
  inline const ::std::string& envs(int index) const;
  inline ::std::string* mutable_envs(int index);
  inline void set_envs(int index, const ::std::string& value);
  inline void set_envs(int index, const char* value);
  inline void set_envs(int index, const char* value, size_t size);
  inline ::std::string* add_envs();
  inline void add_envs(const ::std::string& value);
  inline void add_envs(const char* value);
  inline void add_envs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& envs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_envs();
  
  // optional bool envs_only = 5 [default = false];
  inline bool has_envs_only() const;
  inline void clear_envs_only();
  static const int kEnvsOnlyFieldNumber = 5;
  inline bool envs_only() const;
  inline void set_envs_only(bool value);
  
  // optional int32 max_stdout = 6 [default = 1048576];
  inline bool has_max_stdout() const;
  inline void clear_max_stdout();
  static const int kMaxStdoutFieldNumber = 6;
  inline ::google::protobuf::int32 max_stdout() const;
  inline void set_max_stdout(::google::protobuf::int32 value);
  
  // optional int32 max_stderr = 7 [default = 1048576];
  inline bool has_max_stderr() const;
  inline void clear_max_stderr();
  static const int kMaxStderrFieldNumber = 7;
  inline ::google::protobuf::int32 max_stderr() const;
  inline void set_max_stderr(::google::protobuf::int32 value);
  
  // optional int32 timeout = 8 [default = 60];
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // optional int32 max_memory_mb = 9 [default = 32768];
  inline bool has_max_memory_mb() const;
  inline void clear_max_memory_mb();
  static const int kMaxMemoryMbFieldNumber = 9;
  inline ::google::protobuf::int32 max_memory_mb() const;
  inline void set_max_memory_mb(::google::protobuf::int32 value);
  
  // optional string interpreter = 10;
  inline bool has_interpreter() const;
  inline void clear_interpreter();
  static const int kInterpreterFieldNumber = 10;
  inline const ::std::string& interpreter() const;
  inline void set_interpreter(const ::std::string& value);
  inline void set_interpreter(const char* value);
  inline void set_interpreter(const char* value, size_t size);
  inline ::std::string* mutable_interpreter();
  inline ::std::string* release_interpreter();
  
  // repeated string interpreter_args = 11;
  inline int interpreter_args_size() const;
  inline void clear_interpreter_args();
  static const int kInterpreterArgsFieldNumber = 11;
  inline const ::std::string& interpreter_args(int index) const;
  inline ::std::string* mutable_interpreter_args(int index);
  inline void set_interpreter_args(int index, const ::std::string& value);
  inline void set_interpreter_args(int index, const char* value);
  inline void set_interpreter_args(int index, const char* value, size_t size);
  inline ::std::string* add_interpreter_args();
  inline void add_interpreter_args(const ::std::string& value);
  inline void add_interpreter_args(const char* value);
  inline void add_interpreter_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& interpreter_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_interpreter_args();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.RunScriptRequest)
 private:
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_cwd();
  inline void clear_has_cwd();
  inline void set_has_envs_only();
  inline void clear_has_envs_only();
  inline void set_has_max_stdout();
  inline void clear_has_max_stdout();
  inline void set_has_max_stderr();
  inline void clear_has_max_stderr();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_max_memory_mb();
  inline void clear_has_max_memory_mb();
  inline void set_has_interpreter();
  inline void clear_has_interpreter();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* script_;
  ::std::string* cwd_;
  static const ::std::string _default_cwd_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::std::string> envs_;
  bool envs_only_;
  ::google::protobuf::int32 max_stdout_;
  ::google::protobuf::int32 max_stderr_;
  ::google::protobuf::int32 timeout_;
  ::std::string* interpreter_;
  ::google::protobuf::RepeatedPtrField< ::std::string> interpreter_args_;
  ::google::protobuf::int32 max_memory_mb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static RunScriptRequest* default_instance_;
};
// -------------------------------------------------------------------

class ApplicationStatus : public ::google::protobuf::Message {
 public:
  ApplicationStatus();
  virtual ~ApplicationStatus();
  
  ApplicationStatus(const ApplicationStatus& from);
  
  inline ApplicationStatus& operator=(const ApplicationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplicationStatus& default_instance();
  
  void Swap(ApplicationStatus* other);
  
  // implements Message ----------------------------------------------
  
  ApplicationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplicationStatus& from);
  void MergeFrom(const ApplicationStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .cetty.zurg.slave.ApplicationState state = 1 [default = kUnknown];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline cetty::zurg::slave::ApplicationState state() const;
  inline void set_state(cetty::zurg::slave::ApplicationState value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);
  
  // optional string executable_file = 4;
  inline bool has_executable_file() const;
  inline void clear_executable_file();
  static const int kExecutableFileFieldNumber = 4;
  inline const ::std::string& executable_file() const;
  inline void set_executable_file(const ::std::string& value);
  inline void set_executable_file(const char* value);
  inline void set_executable_file(const char* value, size_t size);
  inline ::std::string* mutable_executable_file();
  inline ::std::string* release_executable_file();
  
  // optional string cwd = 5;
  inline bool has_cwd() const;
  inline void clear_cwd();
  static const int kCwdFieldNumber = 5;
  inline const ::std::string& cwd() const;
  inline void set_cwd(const ::std::string& value);
  inline void set_cwd(const char* value);
  inline void set_cwd(const char* value, size_t size);
  inline ::std::string* mutable_cwd();
  inline ::std::string* release_cwd();
  
  // optional string message = 6;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 6;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // optional string slave_name = 8;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 8;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  
  // optional int64 start_time_us = 10;
  inline bool has_start_time_us() const;
  inline void clear_start_time_us();
  static const int kStartTimeUsFieldNumber = 10;
  inline ::google::protobuf::int64 start_time_us() const;
  inline void set_start_time_us(::google::protobuf::int64 value);
  
  // optional int64 last_stop_time_us = 11;
  inline bool has_last_stop_time_us() const;
  inline void clear_last_stop_time_us();
  static const int kLastStopTimeUsFieldNumber = 11;
  inline ::google::protobuf::int64 last_stop_time_us() const;
  inline void set_last_stop_time_us(::google::protobuf::int64 value);
  
  // optional string proc_stat = 12;
  inline bool has_proc_stat() const;
  inline void clear_proc_stat();
  static const int kProcStatFieldNumber = 12;
  inline const ::std::string& proc_stat() const;
  inline void set_proc_stat(const ::std::string& value);
  inline void set_proc_stat(const char* value);
  inline void set_proc_stat(const char* value, size_t size);
  inline ::std::string* mutable_proc_stat();
  inline ::std::string* release_proc_stat();
  
  // optional string proc_status = 13;
  inline bool has_proc_status() const;
  inline void clear_proc_status();
  static const int kProcStatusFieldNumber = 13;
  inline const ::std::string& proc_status() const;
  inline void set_proc_status(const ::std::string& value);
  inline void set_proc_status(const char* value);
  inline void set_proc_status(const char* value, size_t size);
  inline ::std::string* mutable_proc_status();
  inline ::std::string* release_proc_status();
  
  // optional int32 last_exit_status = 30;
  inline bool has_last_exit_status() const;
  inline void clear_last_exit_status();
  static const int kLastExitStatusFieldNumber = 30;
  inline ::google::protobuf::int32 last_exit_status() const;
  inline void set_last_exit_status(::google::protobuf::int32 value);
  
  // optional int32 last_signaled = 31;
  inline bool has_last_signaled() const;
  inline void clear_last_signaled();
  static const int kLastSignaledFieldNumber = 31;
  inline ::google::protobuf::int32 last_signaled() const;
  inline void set_last_signaled(::google::protobuf::int32 value);
  
  // optional bool last_coredump = 32;
  inline bool has_last_coredump() const;
  inline void clear_last_coredump();
  static const int kLastCoredumpFieldNumber = 32;
  inline bool last_coredump() const;
  inline void set_last_coredump(bool value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.ApplicationStatus)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_executable_file();
  inline void clear_has_executable_file();
  inline void set_has_cwd();
  inline void clear_has_cwd();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_slave_name();
  inline void clear_has_slave_name();
  inline void set_has_start_time_us();
  inline void clear_has_start_time_us();
  inline void set_has_last_stop_time_us();
  inline void clear_has_last_stop_time_us();
  inline void set_has_proc_stat();
  inline void clear_has_proc_stat();
  inline void set_has_proc_status();
  inline void clear_has_proc_status();
  inline void set_has_last_exit_status();
  inline void clear_has_last_exit_status();
  inline void set_has_last_signaled();
  inline void clear_has_last_signaled();
  inline void set_has_last_coredump();
  inline void clear_has_last_coredump();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  int state_;
  ::google::protobuf::int32 pid_;
  ::std::string* executable_file_;
  ::std::string* cwd_;
  ::std::string* message_;
  ::std::string* slave_name_;
  ::google::protobuf::int64 start_time_us_;
  ::google::protobuf::int64 last_stop_time_us_;
  ::std::string* proc_stat_;
  ::std::string* proc_status_;
  ::google::protobuf::int32 last_exit_status_;
  ::google::protobuf::int32 last_signaled_;
  bool last_coredump_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static ApplicationStatus* default_instance_;
};
// -------------------------------------------------------------------

class AddApplicationRequest : public ::google::protobuf::Message {
 public:
  AddApplicationRequest();
  virtual ~AddApplicationRequest();
  
  AddApplicationRequest(const AddApplicationRequest& from);
  
  inline AddApplicationRequest& operator=(const AddApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddApplicationRequest& default_instance();
  
  void Swap(AddApplicationRequest* other);
  
  // implements Message ----------------------------------------------
  
  AddApplicationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddApplicationRequest& from);
  void MergeFrom(const AddApplicationRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string binary = 2;
  inline bool has_binary() const;
  inline void clear_binary();
  static const int kBinaryFieldNumber = 2;
  inline const ::std::string& binary() const;
  inline void set_binary(const ::std::string& value);
  inline void set_binary(const char* value);
  inline void set_binary(const char* value, size_t size);
  inline ::std::string* mutable_binary();
  inline ::std::string* release_binary();
  
  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();
  
  // repeated string envs = 4;
  inline int envs_size() const;
  inline void clear_envs();
  static const int kEnvsFieldNumber = 4;
  inline const ::std::string& envs(int index) const;
  inline ::std::string* mutable_envs(int index);
  inline void set_envs(int index, const ::std::string& value);
  inline void set_envs(int index, const char* value);
  inline void set_envs(int index, const char* value, size_t size);
  inline ::std::string* add_envs();
  inline void add_envs(const ::std::string& value);
  inline void add_envs(const char* value);
  inline void add_envs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& envs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_envs();
  
  // optional bool envs_only = 5 [default = false];
  inline bool has_envs_only() const;
  inline void clear_envs_only();
  static const int kEnvsOnlyFieldNumber = 5;
  inline bool envs_only() const;
  inline void set_envs_only(bool value);
  
  // optional bool redirect_stdout = 6 [default = true];
  inline bool has_redirect_stdout() const;
  inline void clear_redirect_stdout();
  static const int kRedirectStdoutFieldNumber = 6;
  inline bool redirect_stdout() const;
  inline void set_redirect_stdout(bool value);
  
  // optional bool redirect_stderr = 7 [default = true];
  inline bool has_redirect_stderr() const;
  inline void clear_redirect_stderr();
  static const int kRedirectStderrFieldNumber = 7;
  inline bool redirect_stderr() const;
  inline void set_redirect_stderr(bool value);
  
  // required string slave_name = 8;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 8;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  
  // optional int32 max_memory_mb = 9 [default = 32768];
  inline bool has_max_memory_mb() const;
  inline void clear_max_memory_mb();
  static const int kMaxMemoryMbFieldNumber = 9;
  inline ::google::protobuf::int32 max_memory_mb() const;
  inline void set_max_memory_mb(::google::protobuf::int32 value);
  
  // optional string comment = 10;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 10;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // repeated string md5sum_files = 20;
  inline int md5sum_files_size() const;
  inline void clear_md5sum_files();
  static const int kMd5SumFilesFieldNumber = 20;
  inline const ::std::string& md5sum_files(int index) const;
  inline ::std::string* mutable_md5sum_files(int index);
  inline void set_md5sum_files(int index, const ::std::string& value);
  inline void set_md5sum_files(int index, const char* value);
  inline void set_md5sum_files(int index, const char* value, size_t size);
  inline ::std::string* add_md5sum_files();
  inline void add_md5sum_files(const ::std::string& value);
  inline void add_md5sum_files(const char* value);
  inline void add_md5sum_files(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& md5sum_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_md5sum_files();
  
  // repeated string expected_md5sums = 21;
  inline int expected_md5sums_size() const;
  inline void clear_expected_md5sums();
  static const int kExpectedMd5SumsFieldNumber = 21;
  inline const ::std::string& expected_md5sums(int index) const;
  inline ::std::string* mutable_expected_md5sums(int index);
  inline void set_expected_md5sums(int index, const ::std::string& value);
  inline void set_expected_md5sums(int index, const char* value);
  inline void set_expected_md5sums(int index, const char* value, size_t size);
  inline ::std::string* add_expected_md5sums();
  inline void add_expected_md5sums(const ::std::string& value);
  inline void add_expected_md5sums(const char* value);
  inline void add_expected_md5sums(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& expected_md5sums() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_expected_md5sums();
  
  // optional bool md5sum_now = 22;
  inline bool has_md5sum_now() const;
  inline void clear_md5sum_now();
  static const int kMd5SumNowFieldNumber = 22;
  inline bool md5sum_now() const;
  inline void set_md5sum_now(bool value);
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.AddApplicationRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_binary();
  inline void clear_has_binary();
  inline void set_has_envs_only();
  inline void clear_has_envs_only();
  inline void set_has_redirect_stdout();
  inline void clear_has_redirect_stdout();
  inline void set_has_redirect_stderr();
  inline void clear_has_redirect_stderr();
  inline void set_has_slave_name();
  inline void clear_has_slave_name();
  inline void set_has_max_memory_mb();
  inline void clear_has_max_memory_mb();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_md5sum_now();
  inline void clear_has_md5sum_now();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* binary_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::std::string> envs_;
  ::std::string* slave_name_;
  bool envs_only_;
  bool redirect_stdout_;
  bool redirect_stderr_;
  bool md5sum_now_;
  ::google::protobuf::int32 max_memory_mb_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::std::string> md5sum_files_;
  ::google::protobuf::RepeatedPtrField< ::std::string> expected_md5sums_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static AddApplicationRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddApplicationResponse : public ::google::protobuf::Message {
 public:
  AddApplicationResponse();
  virtual ~AddApplicationResponse();
  
  AddApplicationResponse(const AddApplicationResponse& from);
  
  inline AddApplicationResponse& operator=(const AddApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddApplicationResponse& default_instance();
  
  void Swap(AddApplicationResponse* other);
  
  // implements Message ----------------------------------------------
  
  AddApplicationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddApplicationResponse& from);
  void MergeFrom(const AddApplicationResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .cetty.zurg.slave.ApplicationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::zurg::slave::ApplicationStatus& status() const;
  inline ::cetty::zurg::slave::ApplicationStatus* mutable_status();
  inline ::cetty::zurg::slave::ApplicationStatus* release_status();
  
  // optional .cetty.zurg.slave.AddApplicationRequest prev_request = 2;
  inline bool has_prev_request() const;
  inline void clear_prev_request();
  static const int kPrevRequestFieldNumber = 2;
  inline const ::cetty::zurg::slave::AddApplicationRequest& prev_request() const;
  inline ::cetty::zurg::slave::AddApplicationRequest* mutable_prev_request();
  inline ::cetty::zurg::slave::AddApplicationRequest* release_prev_request();
  
  // repeated string md5sums = 3;
  inline int md5sums_size() const;
  inline void clear_md5sums();
  static const int kMd5SumsFieldNumber = 3;
  inline const ::std::string& md5sums(int index) const;
  inline ::std::string* mutable_md5sums(int index);
  inline void set_md5sums(int index, const ::std::string& value);
  inline void set_md5sums(int index, const char* value);
  inline void set_md5sums(int index, const char* value, size_t size);
  inline ::std::string* add_md5sums();
  inline void add_md5sums(const ::std::string& value);
  inline void add_md5sums(const char* value);
  inline void add_md5sums(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& md5sums() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_md5sums();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.AddApplicationResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_prev_request();
  inline void clear_has_prev_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cetty::zurg::slave::ApplicationStatus* status_;
  ::cetty::zurg::slave::AddApplicationRequest* prev_request_;
  ::google::protobuf::RepeatedPtrField< ::std::string> md5sums_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static AddApplicationResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartApplicationsRequest : public ::google::protobuf::Message {
 public:
  StartApplicationsRequest();
  virtual ~StartApplicationsRequest();
  
  StartApplicationsRequest(const StartApplicationsRequest& from);
  
  inline StartApplicationsRequest& operator=(const StartApplicationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartApplicationsRequest& default_instance();
  
  void Swap(StartApplicationsRequest* other);
  
  // implements Message ----------------------------------------------
  
  StartApplicationsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartApplicationsRequest& from);
  void MergeFrom(const StartApplicationsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.StartApplicationsRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static StartApplicationsRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartApplicationsResponse : public ::google::protobuf::Message {
 public:
  StartApplicationsResponse();
  virtual ~StartApplicationsResponse();
  
  StartApplicationsResponse(const StartApplicationsResponse& from);
  
  inline StartApplicationsResponse& operator=(const StartApplicationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartApplicationsResponse& default_instance();
  
  void Swap(StartApplicationsResponse* other);
  
  // implements Message ----------------------------------------------
  
  StartApplicationsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartApplicationsResponse& from);
  void MergeFrom(const StartApplicationsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .cetty.zurg.slave.ApplicationStatus status = 1;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::zurg::slave::ApplicationStatus& status(int index) const;
  inline ::cetty::zurg::slave::ApplicationStatus* mutable_status(int index);
  inline ::cetty::zurg::slave::ApplicationStatus* add_status();
  inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >&
      status() const;
  inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >*
      mutable_status();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.StartApplicationsResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus > status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static StartApplicationsResponse* default_instance_;
};
// -------------------------------------------------------------------

class StopApplicationRequest : public ::google::protobuf::Message {
 public:
  StopApplicationRequest();
  virtual ~StopApplicationRequest();
  
  StopApplicationRequest(const StopApplicationRequest& from);
  
  inline StopApplicationRequest& operator=(const StopApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopApplicationRequest& default_instance();
  
  void Swap(StopApplicationRequest* other);
  
  // implements Message ----------------------------------------------
  
  StopApplicationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopApplicationRequest& from);
  void MergeFrom(const StopApplicationRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string names = 1;
  inline bool has_names() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names() const;
  inline void set_names(const ::std::string& value);
  inline void set_names(const char* value);
  inline void set_names(const char* value, size_t size);
  inline ::std::string* mutable_names();
  inline ::std::string* release_names();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.StopApplicationRequest)
 private:
  inline void set_has_names();
  inline void clear_has_names();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* names_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static StopApplicationRequest* default_instance_;
};
// -------------------------------------------------------------------

class StopApplicationResponse : public ::google::protobuf::Message {
 public:
  StopApplicationResponse();
  virtual ~StopApplicationResponse();
  
  StopApplicationResponse(const StopApplicationResponse& from);
  
  inline StopApplicationResponse& operator=(const StopApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopApplicationResponse& default_instance();
  
  void Swap(StopApplicationResponse* other);
  
  // implements Message ----------------------------------------------
  
  StopApplicationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopApplicationResponse& from);
  void MergeFrom(const StopApplicationResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .cetty.zurg.slave.ApplicationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::zurg::slave::ApplicationStatus& status() const;
  inline ::cetty::zurg::slave::ApplicationStatus* mutable_status();
  inline ::cetty::zurg::slave::ApplicationStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.StopApplicationResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cetty::zurg::slave::ApplicationStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static StopApplicationResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListApplicationsRequest : public ::google::protobuf::Message {
 public:
  ListApplicationsRequest();
  virtual ~ListApplicationsRequest();
  
  ListApplicationsRequest(const ListApplicationsRequest& from);
  
  inline ListApplicationsRequest& operator=(const ListApplicationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListApplicationsRequest& default_instance();
  
  void Swap(ListApplicationsRequest* other);
  
  // implements Message ----------------------------------------------
  
  ListApplicationsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListApplicationsRequest& from);
  void MergeFrom(const ListApplicationsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.ListApplicationsRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static ListApplicationsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListApplicationsResponse : public ::google::protobuf::Message {
 public:
  ListApplicationsResponse();
  virtual ~ListApplicationsResponse();
  
  ListApplicationsResponse(const ListApplicationsResponse& from);
  
  inline ListApplicationsResponse& operator=(const ListApplicationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListApplicationsResponse& default_instance();
  
  void Swap(ListApplicationsResponse* other);
  
  // implements Message ----------------------------------------------
  
  ListApplicationsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListApplicationsResponse& from);
  void MergeFrom(const ListApplicationsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .cetty.zurg.slave.ApplicationStatus status = 1;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::zurg::slave::ApplicationStatus& status(int index) const;
  inline ::cetty::zurg::slave::ApplicationStatus* mutable_status(int index);
  inline ::cetty::zurg::slave::ApplicationStatus* add_status();
  inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >&
      status() const;
  inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >*
      mutable_status();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.ListApplicationsResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus > status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static ListApplicationsResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveApplicationsRequest : public ::google::protobuf::Message {
 public:
  RemoveApplicationsRequest();
  virtual ~RemoveApplicationsRequest();
  
  RemoveApplicationsRequest(const RemoveApplicationsRequest& from);
  
  inline RemoveApplicationsRequest& operator=(const RemoveApplicationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveApplicationsRequest& default_instance();
  
  void Swap(RemoveApplicationsRequest* other);
  
  // implements Message ----------------------------------------------
  
  RemoveApplicationsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveApplicationsRequest& from);
  void MergeFrom(const RemoveApplicationsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const char* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.RemoveApplicationsRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveApplicationsRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoveApplicationsResponse : public ::google::protobuf::Message {
 public:
  RemoveApplicationsResponse();
  virtual ~RemoveApplicationsResponse();
  
  RemoveApplicationsResponse(const RemoveApplicationsResponse& from);
  
  inline RemoveApplicationsResponse& operator=(const RemoveApplicationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveApplicationsResponse& default_instance();
  
  void Swap(RemoveApplicationsResponse* other);
  
  // implements Message ----------------------------------------------
  
  RemoveApplicationsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveApplicationsResponse& from);
  void MergeFrom(const RemoveApplicationsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:cetty.zurg.slave.RemoveApplicationsResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_AssignDesc_cetty_2fzurg_2fslave_2fslave_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fzurg_2fslave_2fslave_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveApplicationsResponse* default_instance_;
};
// ===================================================================

class SlaveService_Stub;

typedef ::cetty::zurg::slave::GetHardwareRequest* GetHardwareRequestPtr;
typedef ::cetty::zurg::slave::GetHardwareRequest const* ConstGetHardwareRequestPtr;
typedef ::cetty::zurg::slave::GetHardwareResponse* GetHardwareResponsePtr;
typedef ::cetty::service::ServiceFuture<GetHardwareResponsePtr> getHardwareServiceFuture;
typedef boost::intrusive_ptr<getHardwareServiceFuture> getHardwareServiceFuturePtr;
typedef ::cetty::zurg::slave::GetFileContentRequest* GetFileContentRequestPtr;
typedef ::cetty::zurg::slave::GetFileContentRequest const* ConstGetFileContentRequestPtr;
typedef ::cetty::zurg::slave::GetFileContentResponse* GetFileContentResponsePtr;
typedef ::cetty::service::ServiceFuture<GetFileContentResponsePtr> getFileContentServiceFuture;
typedef boost::intrusive_ptr<getFileContentServiceFuture> getFileContentServiceFuturePtr;
typedef ::cetty::zurg::slave::GetFileChecksumRequest* GetFileChecksumRequestPtr;
typedef ::cetty::zurg::slave::GetFileChecksumRequest const* ConstGetFileChecksumRequestPtr;
typedef ::cetty::zurg::slave::GetFileChecksumResponse* GetFileChecksumResponsePtr;
typedef ::cetty::service::ServiceFuture<GetFileChecksumResponsePtr> getFileChecksumServiceFuture;
typedef boost::intrusive_ptr<getFileChecksumServiceFuture> getFileChecksumServiceFuturePtr;
typedef ::cetty::zurg::slave::ListProcessesRequest* ListProcessesRequestPtr;
typedef ::cetty::zurg::slave::ListProcessesRequest const* ConstListProcessesRequestPtr;
typedef ::cetty::zurg::slave::ListProcessesResponse* ListProcessesResponsePtr;
typedef ::cetty::service::ServiceFuture<ListProcessesResponsePtr> listProcessesServiceFuture;
typedef boost::intrusive_ptr<listProcessesServiceFuture> listProcessesServiceFuturePtr;
typedef ::cetty::zurg::slave::RunCommandRequest* RunCommandRequestPtr;
typedef ::cetty::zurg::slave::RunCommandRequest const* ConstRunCommandRequestPtr;
typedef ::cetty::zurg::slave::RunCommandResponse* RunCommandResponsePtr;
typedef ::cetty::service::ServiceFuture<RunCommandResponsePtr> runCommandServiceFuture;
typedef boost::intrusive_ptr<runCommandServiceFuture> runCommandServiceFuturePtr;
typedef ::cetty::zurg::slave::RunScriptRequest* RunScriptRequestPtr;
typedef ::cetty::zurg::slave::RunScriptRequest const* ConstRunScriptRequestPtr;
typedef ::cetty::zurg::slave::RunCommandResponse* RunCommandResponsePtr;
typedef ::cetty::service::ServiceFuture<RunCommandResponsePtr> runScriptServiceFuture;
typedef boost::intrusive_ptr<runScriptServiceFuture> runScriptServiceFuturePtr;
typedef ::cetty::zurg::slave::AddApplicationRequest* AddApplicationRequestPtr;
typedef ::cetty::zurg::slave::AddApplicationRequest const* ConstAddApplicationRequestPtr;
typedef ::cetty::zurg::slave::AddApplicationResponse* AddApplicationResponsePtr;
typedef ::cetty::service::ServiceFuture<AddApplicationResponsePtr> addApplicationServiceFuture;
typedef boost::intrusive_ptr<addApplicationServiceFuture> addApplicationServiceFuturePtr;
typedef ::cetty::zurg::slave::StartApplicationsRequest* StartApplicationsRequestPtr;
typedef ::cetty::zurg::slave::StartApplicationsRequest const* ConstStartApplicationsRequestPtr;
typedef ::cetty::zurg::slave::StartApplicationsResponse* StartApplicationsResponsePtr;
typedef ::cetty::service::ServiceFuture<StartApplicationsResponsePtr> startApplicationsServiceFuture;
typedef boost::intrusive_ptr<startApplicationsServiceFuture> startApplicationsServiceFuturePtr;
typedef ::cetty::zurg::slave::StopApplicationRequest* StopApplicationRequestPtr;
typedef ::cetty::zurg::slave::StopApplicationRequest const* ConstStopApplicationRequestPtr;
typedef ::cetty::zurg::slave::StopApplicationResponse* StopApplicationResponsePtr;
typedef ::cetty::service::ServiceFuture<StopApplicationResponsePtr> stopApplicationServiceFuture;
typedef boost::intrusive_ptr<stopApplicationServiceFuture> stopApplicationServiceFuturePtr;
typedef ::cetty::zurg::slave::ListApplicationsRequest* ListApplicationsRequestPtr;
typedef ::cetty::zurg::slave::ListApplicationsRequest const* ConstListApplicationsRequestPtr;
typedef ::cetty::zurg::slave::ListApplicationsResponse* ListApplicationsResponsePtr;
typedef ::cetty::service::ServiceFuture<ListApplicationsResponsePtr> listApplicationsServiceFuture;
typedef boost::intrusive_ptr<listApplicationsServiceFuture> listApplicationsServiceFuturePtr;
typedef ::cetty::zurg::slave::RemoveApplicationsRequest* RemoveApplicationsRequestPtr;
typedef ::cetty::zurg::slave::RemoveApplicationsRequest const* ConstRemoveApplicationsRequestPtr;
typedef ::cetty::zurg::slave::RemoveApplicationsResponse* RemoveApplicationsResponsePtr;
typedef ::cetty::service::ServiceFuture<RemoveApplicationsResponsePtr> removeApplicationsServiceFuture;
typedef boost::intrusive_ptr<removeApplicationsServiceFuture> removeApplicationsServiceFuturePtr;

class SlaveService : public ::cetty::protobuf::service::ProtobufService {
 protected:
  // This class should be treated as an abstract interface.
  inline SlaveService() {};
 public:
  virtual ~SlaveService();
  
  typedef SlaveService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void getHardware(const ConstGetHardwareRequestPtr& request,
                       const GetHardwareResponsePtr& response,
                       const DoneCallback& done);
  virtual void getFileContent(const ConstGetFileContentRequestPtr& request,
                       const GetFileContentResponsePtr& response,
                       const DoneCallback& done);
  virtual void getFileChecksum(const ConstGetFileChecksumRequestPtr& request,
                       const GetFileChecksumResponsePtr& response,
                       const DoneCallback& done);
  virtual void listProcesses(const ConstListProcessesRequestPtr& request,
                       const ListProcessesResponsePtr& response,
                       const DoneCallback& done);
  virtual void runCommand(const ConstRunCommandRequestPtr& request,
                       const RunCommandResponsePtr& response,
                       const DoneCallback& done);
  virtual void runScript(const ConstRunScriptRequestPtr& request,
                       const RunCommandResponsePtr& response,
                       const DoneCallback& done);
  virtual void addApplication(const ConstAddApplicationRequestPtr& request,
                       const AddApplicationResponsePtr& response,
                       const DoneCallback& done);
  virtual void startApplications(const ConstStartApplicationsRequestPtr& request,
                       const StartApplicationsResponsePtr& response,
                       const DoneCallback& done);
  virtual void stopApplication(const ConstStopApplicationRequestPtr& request,
                       const StopApplicationResponsePtr& response,
                       const DoneCallback& done);
  virtual void listApplications(const ConstListApplicationsRequestPtr& request,
                       const ListApplicationsResponsePtr& response,
                       const DoneCallback& done);
  virtual void removeApplications(const ConstRemoveApplicationsRequestPtr& request,
                       const RemoveApplicationsResponsePtr& response,
                       const DoneCallback& done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  const ::cetty::protobuf::service::ConstMessagePtr& request,
                  const ::cetty::protobuf::service::MessagePtr& response,
                  const DoneCallback& done);
  
  const ::google::protobuf::Message* GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message* GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SlaveService);
};

class SlaveService_Stub : public SlaveService {
 public:
  SlaveService_Stub(const ::cetty::service::ClientServicePtr& service);
  ~SlaveService_Stub();
  
  inline const ::cetty::service::ClientServicePtr& channel() {
      return channel_.getService();
  }
  
  // implements SlaveService ------------------------------------------
  
  using SlaveService::getHardware;
  virtual void getHardware(const ConstGetHardwareRequestPtr& request,
                       const getHardwareServiceFuturePtr& future);
  using SlaveService::getFileContent;
  virtual void getFileContent(const ConstGetFileContentRequestPtr& request,
                       const getFileContentServiceFuturePtr& future);
  using SlaveService::getFileChecksum;
  virtual void getFileChecksum(const ConstGetFileChecksumRequestPtr& request,
                       const getFileChecksumServiceFuturePtr& future);
  using SlaveService::listProcesses;
  virtual void listProcesses(const ConstListProcessesRequestPtr& request,
                       const listProcessesServiceFuturePtr& future);
  using SlaveService::runCommand;
  virtual void runCommand(const ConstRunCommandRequestPtr& request,
                       const runCommandServiceFuturePtr& future);
  using SlaveService::runScript;
  virtual void runScript(const ConstRunScriptRequestPtr& request,
                       const runScriptServiceFuturePtr& future);
  using SlaveService::addApplication;
  virtual void addApplication(const ConstAddApplicationRequestPtr& request,
                       const addApplicationServiceFuturePtr& future);
  using SlaveService::startApplications;
  virtual void startApplications(const ConstStartApplicationsRequestPtr& request,
                       const startApplicationsServiceFuturePtr& future);
  using SlaveService::stopApplication;
  virtual void stopApplication(const ConstStopApplicationRequestPtr& request,
                       const stopApplicationServiceFuturePtr& future);
  using SlaveService::listApplications;
  virtual void listApplications(const ConstListApplicationsRequestPtr& request,
                       const listApplicationsServiceFuturePtr& future);
  using SlaveService::removeApplications;
  virtual void removeApplications(const ConstRemoveApplicationsRequestPtr& request,
                       const removeApplicationsServiceFuturePtr& future);
 private:
  cetty::protobuf::service::ProtobufClientServiceAdaptor channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SlaveService_Stub);
};


// ===================================================================


// ===================================================================

// DiskUsage

// required string device = 1;
inline bool DiskUsage::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskUsage::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskUsage::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskUsage::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& DiskUsage::device() const {
  return *device_;
}
inline void DiskUsage::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void DiskUsage::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void DiskUsage::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskUsage::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* DiskUsage::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string mount = 2;
inline bool DiskUsage::has_mount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskUsage::set_has_mount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskUsage::clear_has_mount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskUsage::clear_mount() {
  if (mount_ != &::google::protobuf::internal::kEmptyString) {
    mount_->clear();
  }
  clear_has_mount();
}
inline const ::std::string& DiskUsage::mount() const {
  return *mount_;
}
inline void DiskUsage::set_mount(const ::std::string& value) {
  set_has_mount();
  if (mount_ == &::google::protobuf::internal::kEmptyString) {
    mount_ = new ::std::string;
  }
  mount_->assign(value);
}
inline void DiskUsage::set_mount(const char* value) {
  set_has_mount();
  if (mount_ == &::google::protobuf::internal::kEmptyString) {
    mount_ = new ::std::string;
  }
  mount_->assign(value);
}
inline void DiskUsage::set_mount(const char* value, size_t size) {
  set_has_mount();
  if (mount_ == &::google::protobuf::internal::kEmptyString) {
    mount_ = new ::std::string;
  }
  mount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskUsage::mutable_mount() {
  set_has_mount();
  if (mount_ == &::google::protobuf::internal::kEmptyString) {
    mount_ = new ::std::string;
  }
  return mount_;
}
inline ::std::string* DiskUsage::release_mount() {
  clear_has_mount();
  if (mount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mount_;
    mount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 block_size = 3;
inline bool DiskUsage::has_block_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskUsage::set_has_block_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskUsage::clear_has_block_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskUsage::clear_block_size() {
  block_size_ = 0;
  clear_has_block_size();
}
inline ::google::protobuf::int32 DiskUsage::block_size() const {
  return block_size_;
}
inline void DiskUsage::set_block_size(::google::protobuf::int32 value) {
  set_has_block_size();
  block_size_ = value;
}

// required int64 blocks_all = 4;
inline bool DiskUsage::has_blocks_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskUsage::set_has_blocks_all() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskUsage::clear_has_blocks_all() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskUsage::clear_blocks_all() {
  blocks_all_ = GOOGLE_LONGLONG(0);
  clear_has_blocks_all();
}
inline ::google::protobuf::int64 DiskUsage::blocks_all() const {
  return blocks_all_;
}
inline void DiskUsage::set_blocks_all(::google::protobuf::int64 value) {
  set_has_blocks_all();
  blocks_all_ = value;
}

// required int64 blocks_free = 5;
inline bool DiskUsage::has_blocks_free() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiskUsage::set_has_blocks_free() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiskUsage::clear_has_blocks_free() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiskUsage::clear_blocks_free() {
  blocks_free_ = GOOGLE_LONGLONG(0);
  clear_has_blocks_free();
}
inline ::google::protobuf::int64 DiskUsage::blocks_free() const {
  return blocks_free_;
}
inline void DiskUsage::set_blocks_free(::google::protobuf::int64 value) {
  set_has_blocks_free();
  blocks_free_ = value;
}

// required int64 blocks_avail = 6;
inline bool DiskUsage::has_blocks_avail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiskUsage::set_has_blocks_avail() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiskUsage::clear_has_blocks_avail() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiskUsage::clear_blocks_avail() {
  blocks_avail_ = GOOGLE_LONGLONG(0);
  clear_has_blocks_avail();
}
inline ::google::protobuf::int64 DiskUsage::blocks_avail() const {
  return blocks_avail_;
}
inline void DiskUsage::set_blocks_avail(::google::protobuf::int64 value) {
  set_has_blocks_avail();
  blocks_avail_ = value;
}

// required int64 inodes_all = 7;
inline bool DiskUsage::has_inodes_all() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiskUsage::set_has_inodes_all() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiskUsage::clear_has_inodes_all() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiskUsage::clear_inodes_all() {
  inodes_all_ = GOOGLE_LONGLONG(0);
  clear_has_inodes_all();
}
inline ::google::protobuf::int64 DiskUsage::inodes_all() const {
  return inodes_all_;
}
inline void DiskUsage::set_inodes_all(::google::protobuf::int64 value) {
  set_has_inodes_all();
  inodes_all_ = value;
}

// required int64 inodes_free = 8;
inline bool DiskUsage::has_inodes_free() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DiskUsage::set_has_inodes_free() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DiskUsage::clear_has_inodes_free() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DiskUsage::clear_inodes_free() {
  inodes_free_ = GOOGLE_LONGLONG(0);
  clear_has_inodes_free();
}
inline ::google::protobuf::int64 DiskUsage::inodes_free() const {
  return inodes_free_;
}
inline void DiskUsage::set_inodes_free(::google::protobuf::int64 value) {
  set_has_inodes_free();
  inodes_free_ = value;
}

// required int64 inodes_avail = 9;
inline bool DiskUsage::has_inodes_avail() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DiskUsage::set_has_inodes_avail() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DiskUsage::clear_has_inodes_avail() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DiskUsage::clear_inodes_avail() {
  inodes_avail_ = GOOGLE_LONGLONG(0);
  clear_has_inodes_avail();
}
inline ::google::protobuf::int64 DiskUsage::inodes_avail() const {
  return inodes_avail_;
}
inline void DiskUsage::set_inodes_avail(::google::protobuf::int64 value) {
  set_has_inodes_avail();
  inodes_avail_ = value;
}

// required uint64 fsid = 10;
inline bool DiskUsage::has_fsid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DiskUsage::set_has_fsid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DiskUsage::clear_has_fsid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DiskUsage::clear_fsid() {
  fsid_ = GOOGLE_ULONGLONG(0);
  clear_has_fsid();
}
inline ::google::protobuf::uint64 DiskUsage::fsid() const {
  return fsid_;
}
inline void DiskUsage::set_fsid(::google::protobuf::uint64 value) {
  set_has_fsid();
  fsid_ = value;
}

// required uint64 flag = 11;
inline bool DiskUsage::has_flag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DiskUsage::set_has_flag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DiskUsage::clear_has_flag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DiskUsage::clear_flag() {
  flag_ = GOOGLE_ULONGLONG(0);
  clear_has_flag();
}
inline ::google::protobuf::uint64 DiskUsage::flag() const {
  return flag_;
}
inline void DiskUsage::set_flag(::google::protobuf::uint64 value) {
  set_has_flag();
  flag_ = value;
}

// required uint64 namemax = 12;
inline bool DiskUsage::has_namemax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DiskUsage::set_has_namemax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DiskUsage::clear_has_namemax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DiskUsage::clear_namemax() {
  namemax_ = GOOGLE_ULONGLONG(0);
  clear_has_namemax();
}
inline ::google::protobuf::uint64 DiskUsage::namemax() const {
  return namemax_;
}
inline void DiskUsage::set_namemax(::google::protobuf::uint64 value) {
  set_has_namemax();
  namemax_ = value;
}

// -------------------------------------------------------------------

// GetHardwareRequest

// optional int32 lshw = 1 [default = 0];
inline bool GetHardwareRequest::has_lshw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetHardwareRequest::set_has_lshw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetHardwareRequest::clear_has_lshw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetHardwareRequest::clear_lshw() {
  lshw_ = 0;
  clear_has_lshw();
}
inline ::google::protobuf::int32 GetHardwareRequest::lshw() const {
  return lshw_;
}
inline void GetHardwareRequest::set_lshw(::google::protobuf::int32 value) {
  set_has_lshw();
  lshw_ = value;
}

// -------------------------------------------------------------------

// GetHardwareResponse

// optional string lspci = 1;
inline bool GetHardwareResponse::has_lspci() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetHardwareResponse::set_has_lspci() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetHardwareResponse::clear_has_lspci() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetHardwareResponse::clear_lspci() {
  if (lspci_ != &::google::protobuf::internal::kEmptyString) {
    lspci_->clear();
  }
  clear_has_lspci();
}
inline const ::std::string& GetHardwareResponse::lspci() const {
  return *lspci_;
}
inline void GetHardwareResponse::set_lspci(const ::std::string& value) {
  set_has_lspci();
  if (lspci_ == &::google::protobuf::internal::kEmptyString) {
    lspci_ = new ::std::string;
  }
  lspci_->assign(value);
}
inline void GetHardwareResponse::set_lspci(const char* value) {
  set_has_lspci();
  if (lspci_ == &::google::protobuf::internal::kEmptyString) {
    lspci_ = new ::std::string;
  }
  lspci_->assign(value);
}
inline void GetHardwareResponse::set_lspci(const char* value, size_t size) {
  set_has_lspci();
  if (lspci_ == &::google::protobuf::internal::kEmptyString) {
    lspci_ = new ::std::string;
  }
  lspci_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetHardwareResponse::mutable_lspci() {
  set_has_lspci();
  if (lspci_ == &::google::protobuf::internal::kEmptyString) {
    lspci_ = new ::std::string;
  }
  return lspci_;
}
inline ::std::string* GetHardwareResponse::release_lspci() {
  clear_has_lspci();
  if (lspci_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lspci_;
    lspci_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string lscpu = 2;
inline bool GetHardwareResponse::has_lscpu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetHardwareResponse::set_has_lscpu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetHardwareResponse::clear_has_lscpu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetHardwareResponse::clear_lscpu() {
  if (lscpu_ != &::google::protobuf::internal::kEmptyString) {
    lscpu_->clear();
  }
  clear_has_lscpu();
}
inline const ::std::string& GetHardwareResponse::lscpu() const {
  return *lscpu_;
}
inline void GetHardwareResponse::set_lscpu(const ::std::string& value) {
  set_has_lscpu();
  if (lscpu_ == &::google::protobuf::internal::kEmptyString) {
    lscpu_ = new ::std::string;
  }
  lscpu_->assign(value);
}
inline void GetHardwareResponse::set_lscpu(const char* value) {
  set_has_lscpu();
  if (lscpu_ == &::google::protobuf::internal::kEmptyString) {
    lscpu_ = new ::std::string;
  }
  lscpu_->assign(value);
}
inline void GetHardwareResponse::set_lscpu(const char* value, size_t size) {
  set_has_lscpu();
  if (lscpu_ == &::google::protobuf::internal::kEmptyString) {
    lscpu_ = new ::std::string;
  }
  lscpu_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetHardwareResponse::mutable_lscpu() {
  set_has_lscpu();
  if (lscpu_ == &::google::protobuf::internal::kEmptyString) {
    lscpu_ = new ::std::string;
  }
  return lscpu_;
}
inline ::std::string* GetHardwareResponse::release_lscpu() {
  clear_has_lscpu();
  if (lscpu_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lscpu_;
    lscpu_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string lshw = 3;
inline bool GetHardwareResponse::has_lshw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetHardwareResponse::set_has_lshw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetHardwareResponse::clear_has_lshw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetHardwareResponse::clear_lshw() {
  if (lshw_ != &::google::protobuf::internal::kEmptyString) {
    lshw_->clear();
  }
  clear_has_lshw();
}
inline const ::std::string& GetHardwareResponse::lshw() const {
  return *lshw_;
}
inline void GetHardwareResponse::set_lshw(const ::std::string& value) {
  set_has_lshw();
  if (lshw_ == &::google::protobuf::internal::kEmptyString) {
    lshw_ = new ::std::string;
  }
  lshw_->assign(value);
}
inline void GetHardwareResponse::set_lshw(const char* value) {
  set_has_lshw();
  if (lshw_ == &::google::protobuf::internal::kEmptyString) {
    lshw_ = new ::std::string;
  }
  lshw_->assign(value);
}
inline void GetHardwareResponse::set_lshw(const char* value, size_t size) {
  set_has_lshw();
  if (lshw_ == &::google::protobuf::internal::kEmptyString) {
    lshw_ = new ::std::string;
  }
  lshw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetHardwareResponse::mutable_lshw() {
  set_has_lshw();
  if (lshw_ == &::google::protobuf::internal::kEmptyString) {
    lshw_ = new ::std::string;
  }
  return lshw_;
}
inline ::std::string* GetHardwareResponse::release_lshw() {
  clear_has_lshw();
  if (lshw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lshw_;
    lshw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ifconfig = 4;
inline bool GetHardwareResponse::has_ifconfig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetHardwareResponse::set_has_ifconfig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetHardwareResponse::clear_has_ifconfig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetHardwareResponse::clear_ifconfig() {
  if (ifconfig_ != &::google::protobuf::internal::kEmptyString) {
    ifconfig_->clear();
  }
  clear_has_ifconfig();
}
inline const ::std::string& GetHardwareResponse::ifconfig() const {
  return *ifconfig_;
}
inline void GetHardwareResponse::set_ifconfig(const ::std::string& value) {
  set_has_ifconfig();
  if (ifconfig_ == &::google::protobuf::internal::kEmptyString) {
    ifconfig_ = new ::std::string;
  }
  ifconfig_->assign(value);
}
inline void GetHardwareResponse::set_ifconfig(const char* value) {
  set_has_ifconfig();
  if (ifconfig_ == &::google::protobuf::internal::kEmptyString) {
    ifconfig_ = new ::std::string;
  }
  ifconfig_->assign(value);
}
inline void GetHardwareResponse::set_ifconfig(const char* value, size_t size) {
  set_has_ifconfig();
  if (ifconfig_ == &::google::protobuf::internal::kEmptyString) {
    ifconfig_ = new ::std::string;
  }
  ifconfig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetHardwareResponse::mutable_ifconfig() {
  set_has_ifconfig();
  if (ifconfig_ == &::google::protobuf::internal::kEmptyString) {
    ifconfig_ = new ::std::string;
  }
  return ifconfig_;
}
inline ::std::string* GetHardwareResponse::release_ifconfig() {
  clear_has_ifconfig();
  if (ifconfig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifconfig_;
    ifconfig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetFileContentRequest

// required string file_name = 1;
inline bool GetFileContentRequest::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileContentRequest::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileContentRequest::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileContentRequest::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& GetFileContentRequest::file_name() const {
  return *file_name_;
}
inline void GetFileContentRequest::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void GetFileContentRequest::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void GetFileContentRequest::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileContentRequest::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* GetFileContentRequest::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 max_size = 2 [default = 1048576];
inline bool GetFileContentRequest::has_max_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFileContentRequest::set_has_max_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFileContentRequest::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFileContentRequest::clear_max_size() {
  max_size_ = 1048576;
  clear_has_max_size();
}
inline ::google::protobuf::int32 GetFileContentRequest::max_size() const {
  return max_size_;
}
inline void GetFileContentRequest::set_max_size(::google::protobuf::int32 value) {
  set_has_max_size();
  max_size_ = value;
}

// -------------------------------------------------------------------

// GetFileContentResponse

// required int32 error_code = 1;
inline bool GetFileContentResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileContentResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileContentResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileContentResponse::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 GetFileContentResponse::error_code() const {
  return error_code_;
}
inline void GetFileContentResponse::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional bytes content = 2;
inline bool GetFileContentResponse::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFileContentResponse::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFileContentResponse::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFileContentResponse::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& GetFileContentResponse::content() const {
  return *content_;
}
inline void GetFileContentResponse::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetFileContentResponse::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetFileContentResponse::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileContentResponse::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* GetFileContentResponse::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 file_size = 3;
inline bool GetFileContentResponse::has_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFileContentResponse::set_has_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFileContentResponse::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFileContentResponse::clear_file_size() {
  file_size_ = GOOGLE_LONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::int64 GetFileContentResponse::file_size() const {
  return file_size_;
}
inline void GetFileContentResponse::set_file_size(::google::protobuf::int64 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional int64 modify_time = 4;
inline bool GetFileContentResponse::has_modify_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFileContentResponse::set_has_modify_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFileContentResponse::clear_has_modify_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFileContentResponse::clear_modify_time() {
  modify_time_ = GOOGLE_LONGLONG(0);
  clear_has_modify_time();
}
inline ::google::protobuf::int64 GetFileContentResponse::modify_time() const {
  return modify_time_;
}
inline void GetFileContentResponse::set_modify_time(::google::protobuf::int64 value) {
  set_has_modify_time();
  modify_time_ = value;
}

// optional int64 create_time = 5;
inline bool GetFileContentResponse::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetFileContentResponse::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetFileContentResponse::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetFileContentResponse::clear_create_time() {
  create_time_ = GOOGLE_LONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::int64 GetFileContentResponse::create_time() const {
  return create_time_;
}
inline void GetFileContentResponse::set_create_time(::google::protobuf::int64 value) {
  set_has_create_time();
  create_time_ = value;
}

// -------------------------------------------------------------------

// GetFileChecksumRequest

// repeated string files = 1;
inline int GetFileChecksumRequest::files_size() const {
  return files_.size();
}
inline void GetFileChecksumRequest::clear_files() {
  files_.Clear();
}
inline const ::std::string& GetFileChecksumRequest::files(int index) const {
  return files_.Get(index);
}
inline ::std::string* GetFileChecksumRequest::mutable_files(int index) {
  return files_.Mutable(index);
}
inline void GetFileChecksumRequest::set_files(int index, const ::std::string& value) {
  files_.Mutable(index)->assign(value);
}
inline void GetFileChecksumRequest::set_files(int index, const char* value) {
  files_.Mutable(index)->assign(value);
}
inline void GetFileChecksumRequest::set_files(int index, const char* value, size_t size) {
  files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileChecksumRequest::add_files() {
  return files_.Add();
}
inline void GetFileChecksumRequest::add_files(const ::std::string& value) {
  files_.Add()->assign(value);
}
inline void GetFileChecksumRequest::add_files(const char* value) {
  files_.Add()->assign(value);
}
inline void GetFileChecksumRequest::add_files(const char* value, size_t size) {
  files_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetFileChecksumRequest::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetFileChecksumRequest::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// GetFileChecksumResponse

// repeated string md5sums = 1;
inline int GetFileChecksumResponse::md5sums_size() const {
  return md5sums_.size();
}
inline void GetFileChecksumResponse::clear_md5sums() {
  md5sums_.Clear();
}
inline const ::std::string& GetFileChecksumResponse::md5sums(int index) const {
  return md5sums_.Get(index);
}
inline ::std::string* GetFileChecksumResponse::mutable_md5sums(int index) {
  return md5sums_.Mutable(index);
}
inline void GetFileChecksumResponse::set_md5sums(int index, const ::std::string& value) {
  md5sums_.Mutable(index)->assign(value);
}
inline void GetFileChecksumResponse::set_md5sums(int index, const char* value) {
  md5sums_.Mutable(index)->assign(value);
}
inline void GetFileChecksumResponse::set_md5sums(int index, const char* value, size_t size) {
  md5sums_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileChecksumResponse::add_md5sums() {
  return md5sums_.Add();
}
inline void GetFileChecksumResponse::add_md5sums(const ::std::string& value) {
  md5sums_.Add()->assign(value);
}
inline void GetFileChecksumResponse::add_md5sums(const char* value) {
  md5sums_.Add()->assign(value);
}
inline void GetFileChecksumResponse::add_md5sums(const char* value, size_t size) {
  md5sums_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetFileChecksumResponse::md5sums() const {
  return md5sums_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetFileChecksumResponse::mutable_md5sums() {
  return &md5sums_;
}

// -------------------------------------------------------------------

// ListProcessesRequest

// repeated string include_users = 1;
inline int ListProcessesRequest::include_users_size() const {
  return include_users_.size();
}
inline void ListProcessesRequest::clear_include_users() {
  include_users_.Clear();
}
inline const ::std::string& ListProcessesRequest::include_users(int index) const {
  return include_users_.Get(index);
}
inline ::std::string* ListProcessesRequest::mutable_include_users(int index) {
  return include_users_.Mutable(index);
}
inline void ListProcessesRequest::set_include_users(int index, const ::std::string& value) {
  include_users_.Mutable(index)->assign(value);
}
inline void ListProcessesRequest::set_include_users(int index, const char* value) {
  include_users_.Mutable(index)->assign(value);
}
inline void ListProcessesRequest::set_include_users(int index, const char* value, size_t size) {
  include_users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesRequest::add_include_users() {
  return include_users_.Add();
}
inline void ListProcessesRequest::add_include_users(const ::std::string& value) {
  include_users_.Add()->assign(value);
}
inline void ListProcessesRequest::add_include_users(const char* value) {
  include_users_.Add()->assign(value);
}
inline void ListProcessesRequest::add_include_users(const char* value, size_t size) {
  include_users_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListProcessesRequest::include_users() const {
  return include_users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListProcessesRequest::mutable_include_users() {
  return &include_users_;
}

// repeated string exclude_users = 2;
inline int ListProcessesRequest::exclude_users_size() const {
  return exclude_users_.size();
}
inline void ListProcessesRequest::clear_exclude_users() {
  exclude_users_.Clear();
}
inline const ::std::string& ListProcessesRequest::exclude_users(int index) const {
  return exclude_users_.Get(index);
}
inline ::std::string* ListProcessesRequest::mutable_exclude_users(int index) {
  return exclude_users_.Mutable(index);
}
inline void ListProcessesRequest::set_exclude_users(int index, const ::std::string& value) {
  exclude_users_.Mutable(index)->assign(value);
}
inline void ListProcessesRequest::set_exclude_users(int index, const char* value) {
  exclude_users_.Mutable(index)->assign(value);
}
inline void ListProcessesRequest::set_exclude_users(int index, const char* value, size_t size) {
  exclude_users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesRequest::add_exclude_users() {
  return exclude_users_.Add();
}
inline void ListProcessesRequest::add_exclude_users(const ::std::string& value) {
  exclude_users_.Add()->assign(value);
}
inline void ListProcessesRequest::add_exclude_users(const char* value) {
  exclude_users_.Add()->assign(value);
}
inline void ListProcessesRequest::add_exclude_users(const char* value, size_t size) {
  exclude_users_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListProcessesRequest::exclude_users() const {
  return exclude_users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListProcessesRequest::mutable_exclude_users() {
  return &exclude_users_;
}

// optional bool get_load = 3 [default = false];
inline bool ListProcessesRequest::has_get_load() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListProcessesRequest::set_has_get_load() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListProcessesRequest::clear_has_get_load() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListProcessesRequest::clear_get_load() {
  get_load_ = false;
  clear_has_get_load();
}
inline bool ListProcessesRequest::get_load() const {
  return get_load_;
}
inline void ListProcessesRequest::set_get_load(bool value) {
  set_has_get_load();
  get_load_ = value;
}

// -------------------------------------------------------------------

// ListProcessesResponse_Process

// required int32 pid = 1;
inline bool ListProcessesResponse_Process::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListProcessesResponse_Process::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListProcessesResponse_Process::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListProcessesResponse_Process::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ListProcessesResponse_Process::pid() const {
  return pid_;
}
inline void ListProcessesResponse_Process::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// required string proc_stat = 2;
inline bool ListProcessesResponse_Process::has_proc_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListProcessesResponse_Process::set_has_proc_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListProcessesResponse_Process::clear_has_proc_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListProcessesResponse_Process::clear_proc_stat() {
  if (proc_stat_ != &::google::protobuf::internal::kEmptyString) {
    proc_stat_->clear();
  }
  clear_has_proc_stat();
}
inline const ::std::string& ListProcessesResponse_Process::proc_stat() const {
  return *proc_stat_;
}
inline void ListProcessesResponse_Process::set_proc_stat(const ::std::string& value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void ListProcessesResponse_Process::set_proc_stat(const char* value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void ListProcessesResponse_Process::set_proc_stat(const char* value, size_t size) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse_Process::mutable_proc_stat() {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  return proc_stat_;
}
inline ::std::string* ListProcessesResponse_Process::release_proc_stat() {
  clear_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_stat_;
    proc_stat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string proc_status = 3;
inline bool ListProcessesResponse_Process::has_proc_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListProcessesResponse_Process::set_has_proc_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListProcessesResponse_Process::clear_has_proc_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListProcessesResponse_Process::clear_proc_status() {
  if (proc_status_ != &::google::protobuf::internal::kEmptyString) {
    proc_status_->clear();
  }
  clear_has_proc_status();
}
inline const ::std::string& ListProcessesResponse_Process::proc_status() const {
  return *proc_status_;
}
inline void ListProcessesResponse_Process::set_proc_status(const ::std::string& value) {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  proc_status_->assign(value);
}
inline void ListProcessesResponse_Process::set_proc_status(const char* value) {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  proc_status_->assign(value);
}
inline void ListProcessesResponse_Process::set_proc_status(const char* value, size_t size) {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  proc_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse_Process::mutable_proc_status() {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  return proc_status_;
}
inline ::std::string* ListProcessesResponse_Process::release_proc_status() {
  clear_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_status_;
    proc_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cmdline = 4;
inline bool ListProcessesResponse_Process::has_cmdline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListProcessesResponse_Process::set_has_cmdline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListProcessesResponse_Process::clear_has_cmdline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListProcessesResponse_Process::clear_cmdline() {
  if (cmdline_ != &::google::protobuf::internal::kEmptyString) {
    cmdline_->clear();
  }
  clear_has_cmdline();
}
inline const ::std::string& ListProcessesResponse_Process::cmdline() const {
  return *cmdline_;
}
inline void ListProcessesResponse_Process::set_cmdline(const ::std::string& value) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(value);
}
inline void ListProcessesResponse_Process::set_cmdline(const char* value) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(value);
}
inline void ListProcessesResponse_Process::set_cmdline(const char* value, size_t size) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse_Process::mutable_cmdline() {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  return cmdline_;
}
inline ::std::string* ListProcessesResponse_Process::release_cmdline() {
  clear_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmdline_;
    cmdline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string exe_file = 5;
inline bool ListProcessesResponse_Process::has_exe_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListProcessesResponse_Process::set_has_exe_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListProcessesResponse_Process::clear_has_exe_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListProcessesResponse_Process::clear_exe_file() {
  if (exe_file_ != &::google::protobuf::internal::kEmptyString) {
    exe_file_->clear();
  }
  clear_has_exe_file();
}
inline const ::std::string& ListProcessesResponse_Process::exe_file() const {
  return *exe_file_;
}
inline void ListProcessesResponse_Process::set_exe_file(const ::std::string& value) {
  set_has_exe_file();
  if (exe_file_ == &::google::protobuf::internal::kEmptyString) {
    exe_file_ = new ::std::string;
  }
  exe_file_->assign(value);
}
inline void ListProcessesResponse_Process::set_exe_file(const char* value) {
  set_has_exe_file();
  if (exe_file_ == &::google::protobuf::internal::kEmptyString) {
    exe_file_ = new ::std::string;
  }
  exe_file_->assign(value);
}
inline void ListProcessesResponse_Process::set_exe_file(const char* value, size_t size) {
  set_has_exe_file();
  if (exe_file_ == &::google::protobuf::internal::kEmptyString) {
    exe_file_ = new ::std::string;
  }
  exe_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse_Process::mutable_exe_file() {
  set_has_exe_file();
  if (exe_file_ == &::google::protobuf::internal::kEmptyString) {
    exe_file_ = new ::std::string;
  }
  return exe_file_;
}
inline ::std::string* ListProcessesResponse_Process::release_exe_file() {
  clear_has_exe_file();
  if (exe_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exe_file_;
    exe_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ListProcessesResponse

// repeated .cetty.zurg.slave.ListProcessesResponse.Process processes = 1;
inline int ListProcessesResponse::processes_size() const {
  return processes_.size();
}
inline void ListProcessesResponse::clear_processes() {
  processes_.Clear();
}
inline const ::cetty::zurg::slave::ListProcessesResponse_Process& ListProcessesResponse::processes(int index) const {
  return processes_.Get(index);
}
inline ::cetty::zurg::slave::ListProcessesResponse_Process* ListProcessesResponse::mutable_processes(int index) {
  return processes_.Mutable(index);
}
inline ::cetty::zurg::slave::ListProcessesResponse_Process* ListProcessesResponse::add_processes() {
  return processes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ListProcessesResponse_Process >&
ListProcessesResponse::processes() const {
  return processes_;
}
inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ListProcessesResponse_Process >*
ListProcessesResponse::mutable_processes() {
  return &processes_;
}

// optional string meminfo = 2;
inline bool ListProcessesResponse::has_meminfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListProcessesResponse::set_has_meminfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListProcessesResponse::clear_has_meminfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListProcessesResponse::clear_meminfo() {
  if (meminfo_ != &::google::protobuf::internal::kEmptyString) {
    meminfo_->clear();
  }
  clear_has_meminfo();
}
inline const ::std::string& ListProcessesResponse::meminfo() const {
  return *meminfo_;
}
inline void ListProcessesResponse::set_meminfo(const ::std::string& value) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(value);
}
inline void ListProcessesResponse::set_meminfo(const char* value) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(value);
}
inline void ListProcessesResponse::set_meminfo(const char* value, size_t size) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_meminfo() {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    meminfo_ = new ::std::string;
  }
  return meminfo_;
}
inline ::std::string* ListProcessesResponse::release_meminfo() {
  clear_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meminfo_;
    meminfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proc_stat = 3;
inline bool ListProcessesResponse::has_proc_stat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListProcessesResponse::set_has_proc_stat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListProcessesResponse::clear_has_proc_stat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListProcessesResponse::clear_proc_stat() {
  if (proc_stat_ != &::google::protobuf::internal::kEmptyString) {
    proc_stat_->clear();
  }
  clear_has_proc_stat();
}
inline const ::std::string& ListProcessesResponse::proc_stat() const {
  return *proc_stat_;
}
inline void ListProcessesResponse::set_proc_stat(const ::std::string& value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void ListProcessesResponse::set_proc_stat(const char* value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void ListProcessesResponse::set_proc_stat(const char* value, size_t size) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_proc_stat() {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  return proc_stat_;
}
inline ::std::string* ListProcessesResponse::release_proc_stat() {
  clear_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_stat_;
    proc_stat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string loadavg = 4;
inline bool ListProcessesResponse::has_loadavg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListProcessesResponse::set_has_loadavg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListProcessesResponse::clear_has_loadavg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListProcessesResponse::clear_loadavg() {
  if (loadavg_ != &::google::protobuf::internal::kEmptyString) {
    loadavg_->clear();
  }
  clear_has_loadavg();
}
inline const ::std::string& ListProcessesResponse::loadavg() const {
  return *loadavg_;
}
inline void ListProcessesResponse::set_loadavg(const ::std::string& value) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(value);
}
inline void ListProcessesResponse::set_loadavg(const char* value) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(value);
}
inline void ListProcessesResponse::set_loadavg(const char* value, size_t size) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_loadavg() {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    loadavg_ = new ::std::string;
  }
  return loadavg_;
}
inline ::std::string* ListProcessesResponse::release_loadavg() {
  clear_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loadavg_;
    loadavg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string diskstats = 5;
inline bool ListProcessesResponse::has_diskstats() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListProcessesResponse::set_has_diskstats() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListProcessesResponse::clear_has_diskstats() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListProcessesResponse::clear_diskstats() {
  if (diskstats_ != &::google::protobuf::internal::kEmptyString) {
    diskstats_->clear();
  }
  clear_has_diskstats();
}
inline const ::std::string& ListProcessesResponse::diskstats() const {
  return *diskstats_;
}
inline void ListProcessesResponse::set_diskstats(const ::std::string& value) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(value);
}
inline void ListProcessesResponse::set_diskstats(const char* value) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(value);
}
inline void ListProcessesResponse::set_diskstats(const char* value, size_t size) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_diskstats() {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    diskstats_ = new ::std::string;
  }
  return diskstats_;
}
inline ::std::string* ListProcessesResponse::release_diskstats() {
  clear_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diskstats_;
    diskstats_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string net_dev = 6;
inline bool ListProcessesResponse::has_net_dev() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ListProcessesResponse::set_has_net_dev() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ListProcessesResponse::clear_has_net_dev() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ListProcessesResponse::clear_net_dev() {
  if (net_dev_ != &::google::protobuf::internal::kEmptyString) {
    net_dev_->clear();
  }
  clear_has_net_dev();
}
inline const ::std::string& ListProcessesResponse::net_dev() const {
  return *net_dev_;
}
inline void ListProcessesResponse::set_net_dev(const ::std::string& value) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(value);
}
inline void ListProcessesResponse::set_net_dev(const char* value) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(value);
}
inline void ListProcessesResponse::set_net_dev(const char* value, size_t size) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_net_dev() {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    net_dev_ = new ::std::string;
  }
  return net_dev_;
}
inline ::std::string* ListProcessesResponse::release_net_dev() {
  clear_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_dev_;
    net_dev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string net_tcp = 7;
inline bool ListProcessesResponse::has_net_tcp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ListProcessesResponse::set_has_net_tcp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ListProcessesResponse::clear_has_net_tcp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ListProcessesResponse::clear_net_tcp() {
  if (net_tcp_ != &::google::protobuf::internal::kEmptyString) {
    net_tcp_->clear();
  }
  clear_has_net_tcp();
}
inline const ::std::string& ListProcessesResponse::net_tcp() const {
  return *net_tcp_;
}
inline void ListProcessesResponse::set_net_tcp(const ::std::string& value) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(value);
}
inline void ListProcessesResponse::set_net_tcp(const char* value) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(value);
}
inline void ListProcessesResponse::set_net_tcp(const char* value, size_t size) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_net_tcp() {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    net_tcp_ = new ::std::string;
  }
  return net_tcp_;
}
inline ::std::string* ListProcessesResponse::release_net_tcp() {
  clear_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_tcp_;
    net_tcp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cetty.zurg.slave.DiskUsage disk_usage = 8;
inline int ListProcessesResponse::disk_usage_size() const {
  return disk_usage_.size();
}
inline void ListProcessesResponse::clear_disk_usage() {
  disk_usage_.Clear();
}
inline const ::cetty::zurg::slave::DiskUsage& ListProcessesResponse::disk_usage(int index) const {
  return disk_usage_.Get(index);
}
inline ::cetty::zurg::slave::DiskUsage* ListProcessesResponse::mutable_disk_usage(int index) {
  return disk_usage_.Mutable(index);
}
inline ::cetty::zurg::slave::DiskUsage* ListProcessesResponse::add_disk_usage() {
  return disk_usage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >&
ListProcessesResponse::disk_usage() const {
  return disk_usage_;
}
inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::DiskUsage >*
ListProcessesResponse::mutable_disk_usage() {
  return &disk_usage_;
}

// optional string version = 9;
inline bool ListProcessesResponse::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ListProcessesResponse::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ListProcessesResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ListProcessesResponse::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ListProcessesResponse::version() const {
  return *version_;
}
inline void ListProcessesResponse::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListProcessesResponse::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListProcessesResponse::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ListProcessesResponse::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cpuinfo = 10;
inline bool ListProcessesResponse::has_cpuinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ListProcessesResponse::set_has_cpuinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ListProcessesResponse::clear_has_cpuinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ListProcessesResponse::clear_cpuinfo() {
  if (cpuinfo_ != &::google::protobuf::internal::kEmptyString) {
    cpuinfo_->clear();
  }
  clear_has_cpuinfo();
}
inline const ::std::string& ListProcessesResponse::cpuinfo() const {
  return *cpuinfo_;
}
inline void ListProcessesResponse::set_cpuinfo(const ::std::string& value) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(value);
}
inline void ListProcessesResponse::set_cpuinfo(const char* value) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(value);
}
inline void ListProcessesResponse::set_cpuinfo(const char* value, size_t size) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListProcessesResponse::mutable_cpuinfo() {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    cpuinfo_ = new ::std::string;
  }
  return cpuinfo_;
}
inline ::std::string* ListProcessesResponse::release_cpuinfo() {
  clear_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpuinfo_;
    cpuinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RunCommandRequest

// required string command = 1;
inline bool RunCommandRequest::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunCommandRequest::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunCommandRequest::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunCommandRequest::clear_command() {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& RunCommandRequest::command() const {
  return *command_;
}
inline void RunCommandRequest::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void RunCommandRequest::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void RunCommandRequest::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandRequest::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  return command_;
}
inline ::std::string* RunCommandRequest::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cwd = 2 [default = "/tmp"];
inline bool RunCommandRequest::has_cwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunCommandRequest::set_has_cwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunCommandRequest::clear_has_cwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunCommandRequest::clear_cwd() {
  if (cwd_ != &_default_cwd_) {
    cwd_->assign(_default_cwd_);
  }
  clear_has_cwd();
}
inline const ::std::string& RunCommandRequest::cwd() const {
  return *cwd_;
}
inline void RunCommandRequest::set_cwd(const ::std::string& value) {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
}
inline void RunCommandRequest::set_cwd(const char* value) {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
}
inline void RunCommandRequest::set_cwd(const char* value, size_t size) {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandRequest::mutable_cwd() {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string(_default_cwd_);
  }
  return cwd_;
}
inline ::std::string* RunCommandRequest::release_cwd() {
  clear_has_cwd();
  if (cwd_ == &_default_cwd_) {
    return NULL;
  } else {
    ::std::string* temp = cwd_;
    cwd_ = const_cast< ::std::string*>(&_default_cwd_);
    return temp;
  }
}

// repeated string args = 3;
inline int RunCommandRequest::args_size() const {
  return args_.size();
}
inline void RunCommandRequest::clear_args() {
  args_.Clear();
}
inline const ::std::string& RunCommandRequest::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* RunCommandRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void RunCommandRequest::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void RunCommandRequest::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void RunCommandRequest::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandRequest::add_args() {
  return args_.Add();
}
inline void RunCommandRequest::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void RunCommandRequest::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void RunCommandRequest::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunCommandRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunCommandRequest::mutable_args() {
  return &args_;
}

// repeated string envs = 4;
inline int RunCommandRequest::envs_size() const {
  return envs_.size();
}
inline void RunCommandRequest::clear_envs() {
  envs_.Clear();
}
inline const ::std::string& RunCommandRequest::envs(int index) const {
  return envs_.Get(index);
}
inline ::std::string* RunCommandRequest::mutable_envs(int index) {
  return envs_.Mutable(index);
}
inline void RunCommandRequest::set_envs(int index, const ::std::string& value) {
  envs_.Mutable(index)->assign(value);
}
inline void RunCommandRequest::set_envs(int index, const char* value) {
  envs_.Mutable(index)->assign(value);
}
inline void RunCommandRequest::set_envs(int index, const char* value, size_t size) {
  envs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandRequest::add_envs() {
  return envs_.Add();
}
inline void RunCommandRequest::add_envs(const ::std::string& value) {
  envs_.Add()->assign(value);
}
inline void RunCommandRequest::add_envs(const char* value) {
  envs_.Add()->assign(value);
}
inline void RunCommandRequest::add_envs(const char* value, size_t size) {
  envs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunCommandRequest::envs() const {
  return envs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunCommandRequest::mutable_envs() {
  return &envs_;
}

// optional bool envs_only = 5 [default = false];
inline bool RunCommandRequest::has_envs_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunCommandRequest::set_has_envs_only() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunCommandRequest::clear_has_envs_only() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunCommandRequest::clear_envs_only() {
  envs_only_ = false;
  clear_has_envs_only();
}
inline bool RunCommandRequest::envs_only() const {
  return envs_only_;
}
inline void RunCommandRequest::set_envs_only(bool value) {
  set_has_envs_only();
  envs_only_ = value;
}

// optional int32 max_stdout = 6 [default = 1048576];
inline bool RunCommandRequest::has_max_stdout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RunCommandRequest::set_has_max_stdout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RunCommandRequest::clear_has_max_stdout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RunCommandRequest::clear_max_stdout() {
  max_stdout_ = 1048576;
  clear_has_max_stdout();
}
inline ::google::protobuf::int32 RunCommandRequest::max_stdout() const {
  return max_stdout_;
}
inline void RunCommandRequest::set_max_stdout(::google::protobuf::int32 value) {
  set_has_max_stdout();
  max_stdout_ = value;
}

// optional int32 max_stderr = 7 [default = 1048576];
inline bool RunCommandRequest::has_max_stderr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RunCommandRequest::set_has_max_stderr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RunCommandRequest::clear_has_max_stderr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RunCommandRequest::clear_max_stderr() {
  max_stderr_ = 1048576;
  clear_has_max_stderr();
}
inline ::google::protobuf::int32 RunCommandRequest::max_stderr() const {
  return max_stderr_;
}
inline void RunCommandRequest::set_max_stderr(::google::protobuf::int32 value) {
  set_has_max_stderr();
  max_stderr_ = value;
}

// optional int32 timeout = 8 [default = 3000];
inline bool RunCommandRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RunCommandRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RunCommandRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RunCommandRequest::clear_timeout() {
  timeout_ = 3000;
  clear_has_timeout();
}
inline ::google::protobuf::int32 RunCommandRequest::timeout() const {
  return timeout_;
}
inline void RunCommandRequest::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional int32 max_memory_mb = 9 [default = 32768];
inline bool RunCommandRequest::has_max_memory_mb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RunCommandRequest::set_has_max_memory_mb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RunCommandRequest::clear_has_max_memory_mb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RunCommandRequest::clear_max_memory_mb() {
  max_memory_mb_ = 32768;
  clear_has_max_memory_mb();
}
inline ::google::protobuf::int32 RunCommandRequest::max_memory_mb() const {
  return max_memory_mb_;
}
inline void RunCommandRequest::set_max_memory_mb(::google::protobuf::int32 value) {
  set_has_max_memory_mb();
  max_memory_mb_ = value;
}

// -------------------------------------------------------------------

// RunCommandResponse

// required int32 error_code = 1;
inline bool RunCommandResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunCommandResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunCommandResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunCommandResponse::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 RunCommandResponse::error_code() const {
  return error_code_;
}
inline void RunCommandResponse::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional int32 pid = 2;
inline bool RunCommandResponse::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunCommandResponse::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunCommandResponse::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunCommandResponse::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 RunCommandResponse::pid() const {
  return pid_;
}
inline void RunCommandResponse::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional int32 status = 3;
inline bool RunCommandResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RunCommandResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RunCommandResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RunCommandResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RunCommandResponse::status() const {
  return status_;
}
inline void RunCommandResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional bytes std_output = 4;
inline bool RunCommandResponse::has_std_output() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RunCommandResponse::set_has_std_output() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RunCommandResponse::clear_has_std_output() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RunCommandResponse::clear_std_output() {
  if (std_output_ != &::google::protobuf::internal::kEmptyString) {
    std_output_->clear();
  }
  clear_has_std_output();
}
inline const ::std::string& RunCommandResponse::std_output() const {
  return *std_output_;
}
inline void RunCommandResponse::set_std_output(const ::std::string& value) {
  set_has_std_output();
  if (std_output_ == &::google::protobuf::internal::kEmptyString) {
    std_output_ = new ::std::string;
  }
  std_output_->assign(value);
}
inline void RunCommandResponse::set_std_output(const char* value) {
  set_has_std_output();
  if (std_output_ == &::google::protobuf::internal::kEmptyString) {
    std_output_ = new ::std::string;
  }
  std_output_->assign(value);
}
inline void RunCommandResponse::set_std_output(const void* value, size_t size) {
  set_has_std_output();
  if (std_output_ == &::google::protobuf::internal::kEmptyString) {
    std_output_ = new ::std::string;
  }
  std_output_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandResponse::mutable_std_output() {
  set_has_std_output();
  if (std_output_ == &::google::protobuf::internal::kEmptyString) {
    std_output_ = new ::std::string;
  }
  return std_output_;
}
inline ::std::string* RunCommandResponse::release_std_output() {
  clear_has_std_output();
  if (std_output_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = std_output_;
    std_output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes std_error = 5;
inline bool RunCommandResponse::has_std_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunCommandResponse::set_has_std_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunCommandResponse::clear_has_std_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunCommandResponse::clear_std_error() {
  if (std_error_ != &::google::protobuf::internal::kEmptyString) {
    std_error_->clear();
  }
  clear_has_std_error();
}
inline const ::std::string& RunCommandResponse::std_error() const {
  return *std_error_;
}
inline void RunCommandResponse::set_std_error(const ::std::string& value) {
  set_has_std_error();
  if (std_error_ == &::google::protobuf::internal::kEmptyString) {
    std_error_ = new ::std::string;
  }
  std_error_->assign(value);
}
inline void RunCommandResponse::set_std_error(const char* value) {
  set_has_std_error();
  if (std_error_ == &::google::protobuf::internal::kEmptyString) {
    std_error_ = new ::std::string;
  }
  std_error_->assign(value);
}
inline void RunCommandResponse::set_std_error(const void* value, size_t size) {
  set_has_std_error();
  if (std_error_ == &::google::protobuf::internal::kEmptyString) {
    std_error_ = new ::std::string;
  }
  std_error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandResponse::mutable_std_error() {
  set_has_std_error();
  if (std_error_ == &::google::protobuf::internal::kEmptyString) {
    std_error_ = new ::std::string;
  }
  return std_error_;
}
inline ::std::string* RunCommandResponse::release_std_error() {
  clear_has_std_error();
  if (std_error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = std_error_;
    std_error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string executable_file = 6;
inline bool RunCommandResponse::has_executable_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RunCommandResponse::set_has_executable_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RunCommandResponse::clear_has_executable_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RunCommandResponse::clear_executable_file() {
  if (executable_file_ != &::google::protobuf::internal::kEmptyString) {
    executable_file_->clear();
  }
  clear_has_executable_file();
}
inline const ::std::string& RunCommandResponse::executable_file() const {
  return *executable_file_;
}
inline void RunCommandResponse::set_executable_file(const ::std::string& value) {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  executable_file_->assign(value);
}
inline void RunCommandResponse::set_executable_file(const char* value) {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  executable_file_->assign(value);
}
inline void RunCommandResponse::set_executable_file(const char* value, size_t size) {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  executable_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunCommandResponse::mutable_executable_file() {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  return executable_file_;
}
inline ::std::string* RunCommandResponse::release_executable_file() {
  clear_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executable_file_;
    executable_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 start_time_us = 16;
inline bool RunCommandResponse::has_start_time_us() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RunCommandResponse::set_has_start_time_us() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RunCommandResponse::clear_has_start_time_us() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RunCommandResponse::clear_start_time_us() {
  start_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_start_time_us();
}
inline ::google::protobuf::int64 RunCommandResponse::start_time_us() const {
  return start_time_us_;
}
inline void RunCommandResponse::set_start_time_us(::google::protobuf::int64 value) {
  set_has_start_time_us();
  start_time_us_ = value;
}

// optional int64 finish_time_us = 17;
inline bool RunCommandResponse::has_finish_time_us() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RunCommandResponse::set_has_finish_time_us() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RunCommandResponse::clear_has_finish_time_us() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RunCommandResponse::clear_finish_time_us() {
  finish_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_finish_time_us();
}
inline ::google::protobuf::int64 RunCommandResponse::finish_time_us() const {
  return finish_time_us_;
}
inline void RunCommandResponse::set_finish_time_us(::google::protobuf::int64 value) {
  set_has_finish_time_us();
  finish_time_us_ = value;
}

// optional float user_time = 18;
inline bool RunCommandResponse::has_user_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RunCommandResponse::set_has_user_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RunCommandResponse::clear_has_user_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RunCommandResponse::clear_user_time() {
  user_time_ = 0;
  clear_has_user_time();
}
inline float RunCommandResponse::user_time() const {
  return user_time_;
}
inline void RunCommandResponse::set_user_time(float value) {
  set_has_user_time();
  user_time_ = value;
}

// optional float system_time = 19;
inline bool RunCommandResponse::has_system_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RunCommandResponse::set_has_system_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RunCommandResponse::clear_has_system_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RunCommandResponse::clear_system_time() {
  system_time_ = 0;
  clear_has_system_time();
}
inline float RunCommandResponse::system_time() const {
  return system_time_;
}
inline void RunCommandResponse::set_system_time(float value) {
  set_has_system_time();
  system_time_ = value;
}

// optional int64 memory_maxrss_kb = 20;
inline bool RunCommandResponse::has_memory_maxrss_kb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RunCommandResponse::set_has_memory_maxrss_kb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RunCommandResponse::clear_has_memory_maxrss_kb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RunCommandResponse::clear_memory_maxrss_kb() {
  memory_maxrss_kb_ = GOOGLE_LONGLONG(0);
  clear_has_memory_maxrss_kb();
}
inline ::google::protobuf::int64 RunCommandResponse::memory_maxrss_kb() const {
  return memory_maxrss_kb_;
}
inline void RunCommandResponse::set_memory_maxrss_kb(::google::protobuf::int64 value) {
  set_has_memory_maxrss_kb();
  memory_maxrss_kb_ = value;
}

// optional int32 exit_status = 30 [default = 0];
inline bool RunCommandResponse::has_exit_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RunCommandResponse::set_has_exit_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RunCommandResponse::clear_has_exit_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RunCommandResponse::clear_exit_status() {
  exit_status_ = 0;
  clear_has_exit_status();
}
inline ::google::protobuf::int32 RunCommandResponse::exit_status() const {
  return exit_status_;
}
inline void RunCommandResponse::set_exit_status(::google::protobuf::int32 value) {
  set_has_exit_status();
  exit_status_ = value;
}

// optional int32 signaled = 31 [default = 0];
inline bool RunCommandResponse::has_signaled() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RunCommandResponse::set_has_signaled() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RunCommandResponse::clear_has_signaled() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RunCommandResponse::clear_signaled() {
  signaled_ = 0;
  clear_has_signaled();
}
inline ::google::protobuf::int32 RunCommandResponse::signaled() const {
  return signaled_;
}
inline void RunCommandResponse::set_signaled(::google::protobuf::int32 value) {
  set_has_signaled();
  signaled_ = value;
}

// optional bool coredump = 32 [default = false];
inline bool RunCommandResponse::has_coredump() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RunCommandResponse::set_has_coredump() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RunCommandResponse::clear_has_coredump() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RunCommandResponse::clear_coredump() {
  coredump_ = false;
  clear_has_coredump();
}
inline bool RunCommandResponse::coredump() const {
  return coredump_;
}
inline void RunCommandResponse::set_coredump(bool value) {
  set_has_coredump();
  coredump_ = value;
}

// -------------------------------------------------------------------

// RunScriptRequest

// required bytes script = 1;
inline bool RunScriptRequest::has_script() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunScriptRequest::set_has_script() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunScriptRequest::clear_has_script() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunScriptRequest::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& RunScriptRequest::script() const {
  return *script_;
}
inline void RunScriptRequest::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void RunScriptRequest::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void RunScriptRequest::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunScriptRequest::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* RunScriptRequest::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cwd = 2 [default = "/tmp"];
inline bool RunScriptRequest::has_cwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunScriptRequest::set_has_cwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunScriptRequest::clear_has_cwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunScriptRequest::clear_cwd() {
  if (cwd_ != &_default_cwd_) {
    cwd_->assign(_default_cwd_);
  }
  clear_has_cwd();
}
inline const ::std::string& RunScriptRequest::cwd() const {
  return *cwd_;
}
inline void RunScriptRequest::set_cwd(const ::std::string& value) {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
}
inline void RunScriptRequest::set_cwd(const char* value) {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
}
inline void RunScriptRequest::set_cwd(const char* value, size_t size) {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunScriptRequest::mutable_cwd() {
  set_has_cwd();
  if (cwd_ == &_default_cwd_) {
    cwd_ = new ::std::string(_default_cwd_);
  }
  return cwd_;
}
inline ::std::string* RunScriptRequest::release_cwd() {
  clear_has_cwd();
  if (cwd_ == &_default_cwd_) {
    return NULL;
  } else {
    ::std::string* temp = cwd_;
    cwd_ = const_cast< ::std::string*>(&_default_cwd_);
    return temp;
  }
}

// repeated string args = 3;
inline int RunScriptRequest::args_size() const {
  return args_.size();
}
inline void RunScriptRequest::clear_args() {
  args_.Clear();
}
inline const ::std::string& RunScriptRequest::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* RunScriptRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void RunScriptRequest::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void RunScriptRequest::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void RunScriptRequest::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunScriptRequest::add_args() {
  return args_.Add();
}
inline void RunScriptRequest::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void RunScriptRequest::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void RunScriptRequest::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunScriptRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunScriptRequest::mutable_args() {
  return &args_;
}

// repeated string envs = 4;
inline int RunScriptRequest::envs_size() const {
  return envs_.size();
}
inline void RunScriptRequest::clear_envs() {
  envs_.Clear();
}
inline const ::std::string& RunScriptRequest::envs(int index) const {
  return envs_.Get(index);
}
inline ::std::string* RunScriptRequest::mutable_envs(int index) {
  return envs_.Mutable(index);
}
inline void RunScriptRequest::set_envs(int index, const ::std::string& value) {
  envs_.Mutable(index)->assign(value);
}
inline void RunScriptRequest::set_envs(int index, const char* value) {
  envs_.Mutable(index)->assign(value);
}
inline void RunScriptRequest::set_envs(int index, const char* value, size_t size) {
  envs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunScriptRequest::add_envs() {
  return envs_.Add();
}
inline void RunScriptRequest::add_envs(const ::std::string& value) {
  envs_.Add()->assign(value);
}
inline void RunScriptRequest::add_envs(const char* value) {
  envs_.Add()->assign(value);
}
inline void RunScriptRequest::add_envs(const char* value, size_t size) {
  envs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunScriptRequest::envs() const {
  return envs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunScriptRequest::mutable_envs() {
  return &envs_;
}

// optional bool envs_only = 5 [default = false];
inline bool RunScriptRequest::has_envs_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunScriptRequest::set_has_envs_only() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunScriptRequest::clear_has_envs_only() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunScriptRequest::clear_envs_only() {
  envs_only_ = false;
  clear_has_envs_only();
}
inline bool RunScriptRequest::envs_only() const {
  return envs_only_;
}
inline void RunScriptRequest::set_envs_only(bool value) {
  set_has_envs_only();
  envs_only_ = value;
}

// optional int32 max_stdout = 6 [default = 1048576];
inline bool RunScriptRequest::has_max_stdout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RunScriptRequest::set_has_max_stdout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RunScriptRequest::clear_has_max_stdout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RunScriptRequest::clear_max_stdout() {
  max_stdout_ = 1048576;
  clear_has_max_stdout();
}
inline ::google::protobuf::int32 RunScriptRequest::max_stdout() const {
  return max_stdout_;
}
inline void RunScriptRequest::set_max_stdout(::google::protobuf::int32 value) {
  set_has_max_stdout();
  max_stdout_ = value;
}

// optional int32 max_stderr = 7 [default = 1048576];
inline bool RunScriptRequest::has_max_stderr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RunScriptRequest::set_has_max_stderr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RunScriptRequest::clear_has_max_stderr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RunScriptRequest::clear_max_stderr() {
  max_stderr_ = 1048576;
  clear_has_max_stderr();
}
inline ::google::protobuf::int32 RunScriptRequest::max_stderr() const {
  return max_stderr_;
}
inline void RunScriptRequest::set_max_stderr(::google::protobuf::int32 value) {
  set_has_max_stderr();
  max_stderr_ = value;
}

// optional int32 timeout = 8 [default = 60];
inline bool RunScriptRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RunScriptRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RunScriptRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RunScriptRequest::clear_timeout() {
  timeout_ = 60;
  clear_has_timeout();
}
inline ::google::protobuf::int32 RunScriptRequest::timeout() const {
  return timeout_;
}
inline void RunScriptRequest::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional int32 max_memory_mb = 9 [default = 32768];
inline bool RunScriptRequest::has_max_memory_mb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RunScriptRequest::set_has_max_memory_mb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RunScriptRequest::clear_has_max_memory_mb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RunScriptRequest::clear_max_memory_mb() {
  max_memory_mb_ = 32768;
  clear_has_max_memory_mb();
}
inline ::google::protobuf::int32 RunScriptRequest::max_memory_mb() const {
  return max_memory_mb_;
}
inline void RunScriptRequest::set_max_memory_mb(::google::protobuf::int32 value) {
  set_has_max_memory_mb();
  max_memory_mb_ = value;
}

// optional string interpreter = 10;
inline bool RunScriptRequest::has_interpreter() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RunScriptRequest::set_has_interpreter() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RunScriptRequest::clear_has_interpreter() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RunScriptRequest::clear_interpreter() {
  if (interpreter_ != &::google::protobuf::internal::kEmptyString) {
    interpreter_->clear();
  }
  clear_has_interpreter();
}
inline const ::std::string& RunScriptRequest::interpreter() const {
  return *interpreter_;
}
inline void RunScriptRequest::set_interpreter(const ::std::string& value) {
  set_has_interpreter();
  if (interpreter_ == &::google::protobuf::internal::kEmptyString) {
    interpreter_ = new ::std::string;
  }
  interpreter_->assign(value);
}
inline void RunScriptRequest::set_interpreter(const char* value) {
  set_has_interpreter();
  if (interpreter_ == &::google::protobuf::internal::kEmptyString) {
    interpreter_ = new ::std::string;
  }
  interpreter_->assign(value);
}
inline void RunScriptRequest::set_interpreter(const char* value, size_t size) {
  set_has_interpreter();
  if (interpreter_ == &::google::protobuf::internal::kEmptyString) {
    interpreter_ = new ::std::string;
  }
  interpreter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunScriptRequest::mutable_interpreter() {
  set_has_interpreter();
  if (interpreter_ == &::google::protobuf::internal::kEmptyString) {
    interpreter_ = new ::std::string;
  }
  return interpreter_;
}
inline ::std::string* RunScriptRequest::release_interpreter() {
  clear_has_interpreter();
  if (interpreter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interpreter_;
    interpreter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string interpreter_args = 11;
inline int RunScriptRequest::interpreter_args_size() const {
  return interpreter_args_.size();
}
inline void RunScriptRequest::clear_interpreter_args() {
  interpreter_args_.Clear();
}
inline const ::std::string& RunScriptRequest::interpreter_args(int index) const {
  return interpreter_args_.Get(index);
}
inline ::std::string* RunScriptRequest::mutable_interpreter_args(int index) {
  return interpreter_args_.Mutable(index);
}
inline void RunScriptRequest::set_interpreter_args(int index, const ::std::string& value) {
  interpreter_args_.Mutable(index)->assign(value);
}
inline void RunScriptRequest::set_interpreter_args(int index, const char* value) {
  interpreter_args_.Mutable(index)->assign(value);
}
inline void RunScriptRequest::set_interpreter_args(int index, const char* value, size_t size) {
  interpreter_args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunScriptRequest::add_interpreter_args() {
  return interpreter_args_.Add();
}
inline void RunScriptRequest::add_interpreter_args(const ::std::string& value) {
  interpreter_args_.Add()->assign(value);
}
inline void RunScriptRequest::add_interpreter_args(const char* value) {
  interpreter_args_.Add()->assign(value);
}
inline void RunScriptRequest::add_interpreter_args(const char* value, size_t size) {
  interpreter_args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunScriptRequest::interpreter_args() const {
  return interpreter_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunScriptRequest::mutable_interpreter_args() {
  return &interpreter_args_;
}

// -------------------------------------------------------------------

// ApplicationStatus

// required .cetty.zurg.slave.ApplicationState state = 1 [default = kUnknown];
inline bool ApplicationStatus::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplicationStatus::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplicationStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplicationStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline cetty::zurg::slave::ApplicationState ApplicationStatus::state() const {
  return static_cast< cetty::zurg::slave::ApplicationState >(state_);
}
inline void ApplicationStatus::set_state(cetty::zurg::slave::ApplicationState value) {
  GOOGLE_DCHECK(cetty::zurg::slave::ApplicationState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required string name = 2;
inline bool ApplicationStatus::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplicationStatus::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplicationStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplicationStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ApplicationStatus::name() const {
  return *name_;
}
inline void ApplicationStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ApplicationStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ApplicationStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ApplicationStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 pid = 3;
inline bool ApplicationStatus::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplicationStatus::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplicationStatus::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplicationStatus::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ApplicationStatus::pid() const {
  return pid_;
}
inline void ApplicationStatus::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional string executable_file = 4;
inline bool ApplicationStatus::has_executable_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplicationStatus::set_has_executable_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplicationStatus::clear_has_executable_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplicationStatus::clear_executable_file() {
  if (executable_file_ != &::google::protobuf::internal::kEmptyString) {
    executable_file_->clear();
  }
  clear_has_executable_file();
}
inline const ::std::string& ApplicationStatus::executable_file() const {
  return *executable_file_;
}
inline void ApplicationStatus::set_executable_file(const ::std::string& value) {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  executable_file_->assign(value);
}
inline void ApplicationStatus::set_executable_file(const char* value) {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  executable_file_->assign(value);
}
inline void ApplicationStatus::set_executable_file(const char* value, size_t size) {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  executable_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_executable_file() {
  set_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    executable_file_ = new ::std::string;
  }
  return executable_file_;
}
inline ::std::string* ApplicationStatus::release_executable_file() {
  clear_has_executable_file();
  if (executable_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executable_file_;
    executable_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cwd = 5;
inline bool ApplicationStatus::has_cwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplicationStatus::set_has_cwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplicationStatus::clear_has_cwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplicationStatus::clear_cwd() {
  if (cwd_ != &::google::protobuf::internal::kEmptyString) {
    cwd_->clear();
  }
  clear_has_cwd();
}
inline const ::std::string& ApplicationStatus::cwd() const {
  return *cwd_;
}
inline void ApplicationStatus::set_cwd(const ::std::string& value) {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::kEmptyString) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
}
inline void ApplicationStatus::set_cwd(const char* value) {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::kEmptyString) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
}
inline void ApplicationStatus::set_cwd(const char* value, size_t size) {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::kEmptyString) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_cwd() {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::kEmptyString) {
    cwd_ = new ::std::string;
  }
  return cwd_;
}
inline ::std::string* ApplicationStatus::release_cwd() {
  clear_has_cwd();
  if (cwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cwd_;
    cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string message = 6;
inline bool ApplicationStatus::has_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplicationStatus::set_has_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplicationStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplicationStatus::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ApplicationStatus::message() const {
  return *message_;
}
inline void ApplicationStatus::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ApplicationStatus::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ApplicationStatus::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ApplicationStatus::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string slave_name = 8;
inline bool ApplicationStatus::has_slave_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ApplicationStatus::set_has_slave_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ApplicationStatus::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ApplicationStatus::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& ApplicationStatus::slave_name() const {
  return *slave_name_;
}
inline void ApplicationStatus::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void ApplicationStatus::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void ApplicationStatus::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* ApplicationStatus::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 start_time_us = 10;
inline bool ApplicationStatus::has_start_time_us() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ApplicationStatus::set_has_start_time_us() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ApplicationStatus::clear_has_start_time_us() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ApplicationStatus::clear_start_time_us() {
  start_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_start_time_us();
}
inline ::google::protobuf::int64 ApplicationStatus::start_time_us() const {
  return start_time_us_;
}
inline void ApplicationStatus::set_start_time_us(::google::protobuf::int64 value) {
  set_has_start_time_us();
  start_time_us_ = value;
}

// optional int64 last_stop_time_us = 11;
inline bool ApplicationStatus::has_last_stop_time_us() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ApplicationStatus::set_has_last_stop_time_us() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ApplicationStatus::clear_has_last_stop_time_us() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ApplicationStatus::clear_last_stop_time_us() {
  last_stop_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_last_stop_time_us();
}
inline ::google::protobuf::int64 ApplicationStatus::last_stop_time_us() const {
  return last_stop_time_us_;
}
inline void ApplicationStatus::set_last_stop_time_us(::google::protobuf::int64 value) {
  set_has_last_stop_time_us();
  last_stop_time_us_ = value;
}

// optional string proc_stat = 12;
inline bool ApplicationStatus::has_proc_stat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ApplicationStatus::set_has_proc_stat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ApplicationStatus::clear_has_proc_stat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ApplicationStatus::clear_proc_stat() {
  if (proc_stat_ != &::google::protobuf::internal::kEmptyString) {
    proc_stat_->clear();
  }
  clear_has_proc_stat();
}
inline const ::std::string& ApplicationStatus::proc_stat() const {
  return *proc_stat_;
}
inline void ApplicationStatus::set_proc_stat(const ::std::string& value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void ApplicationStatus::set_proc_stat(const char* value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
}
inline void ApplicationStatus::set_proc_stat(const char* value, size_t size) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_proc_stat() {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    proc_stat_ = new ::std::string;
  }
  return proc_stat_;
}
inline ::std::string* ApplicationStatus::release_proc_stat() {
  clear_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_stat_;
    proc_stat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proc_status = 13;
inline bool ApplicationStatus::has_proc_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ApplicationStatus::set_has_proc_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ApplicationStatus::clear_has_proc_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ApplicationStatus::clear_proc_status() {
  if (proc_status_ != &::google::protobuf::internal::kEmptyString) {
    proc_status_->clear();
  }
  clear_has_proc_status();
}
inline const ::std::string& ApplicationStatus::proc_status() const {
  return *proc_status_;
}
inline void ApplicationStatus::set_proc_status(const ::std::string& value) {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  proc_status_->assign(value);
}
inline void ApplicationStatus::set_proc_status(const char* value) {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  proc_status_->assign(value);
}
inline void ApplicationStatus::set_proc_status(const char* value, size_t size) {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  proc_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationStatus::mutable_proc_status() {
  set_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    proc_status_ = new ::std::string;
  }
  return proc_status_;
}
inline ::std::string* ApplicationStatus::release_proc_status() {
  clear_has_proc_status();
  if (proc_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_status_;
    proc_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 last_exit_status = 30;
inline bool ApplicationStatus::has_last_exit_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ApplicationStatus::set_has_last_exit_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ApplicationStatus::clear_has_last_exit_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ApplicationStatus::clear_last_exit_status() {
  last_exit_status_ = 0;
  clear_has_last_exit_status();
}
inline ::google::protobuf::int32 ApplicationStatus::last_exit_status() const {
  return last_exit_status_;
}
inline void ApplicationStatus::set_last_exit_status(::google::protobuf::int32 value) {
  set_has_last_exit_status();
  last_exit_status_ = value;
}

// optional int32 last_signaled = 31;
inline bool ApplicationStatus::has_last_signaled() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ApplicationStatus::set_has_last_signaled() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ApplicationStatus::clear_has_last_signaled() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ApplicationStatus::clear_last_signaled() {
  last_signaled_ = 0;
  clear_has_last_signaled();
}
inline ::google::protobuf::int32 ApplicationStatus::last_signaled() const {
  return last_signaled_;
}
inline void ApplicationStatus::set_last_signaled(::google::protobuf::int32 value) {
  set_has_last_signaled();
  last_signaled_ = value;
}

// optional bool last_coredump = 32;
inline bool ApplicationStatus::has_last_coredump() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ApplicationStatus::set_has_last_coredump() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ApplicationStatus::clear_has_last_coredump() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ApplicationStatus::clear_last_coredump() {
  last_coredump_ = false;
  clear_has_last_coredump();
}
inline bool ApplicationStatus::last_coredump() const {
  return last_coredump_;
}
inline void ApplicationStatus::set_last_coredump(bool value) {
  set_has_last_coredump();
  last_coredump_ = value;
}

// -------------------------------------------------------------------

// AddApplicationRequest

// required string name = 1;
inline bool AddApplicationRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddApplicationRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddApplicationRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddApplicationRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AddApplicationRequest::name() const {
  return *name_;
}
inline void AddApplicationRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddApplicationRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddApplicationRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AddApplicationRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string binary = 2;
inline bool AddApplicationRequest::has_binary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddApplicationRequest::set_has_binary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddApplicationRequest::clear_has_binary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddApplicationRequest::clear_binary() {
  if (binary_ != &::google::protobuf::internal::kEmptyString) {
    binary_->clear();
  }
  clear_has_binary();
}
inline const ::std::string& AddApplicationRequest::binary() const {
  return *binary_;
}
inline void AddApplicationRequest::set_binary(const ::std::string& value) {
  set_has_binary();
  if (binary_ == &::google::protobuf::internal::kEmptyString) {
    binary_ = new ::std::string;
  }
  binary_->assign(value);
}
inline void AddApplicationRequest::set_binary(const char* value) {
  set_has_binary();
  if (binary_ == &::google::protobuf::internal::kEmptyString) {
    binary_ = new ::std::string;
  }
  binary_->assign(value);
}
inline void AddApplicationRequest::set_binary(const char* value, size_t size) {
  set_has_binary();
  if (binary_ == &::google::protobuf::internal::kEmptyString) {
    binary_ = new ::std::string;
  }
  binary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::mutable_binary() {
  set_has_binary();
  if (binary_ == &::google::protobuf::internal::kEmptyString) {
    binary_ = new ::std::string;
  }
  return binary_;
}
inline ::std::string* AddApplicationRequest::release_binary() {
  clear_has_binary();
  if (binary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = binary_;
    binary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string args = 3;
inline int AddApplicationRequest::args_size() const {
  return args_.size();
}
inline void AddApplicationRequest::clear_args() {
  args_.Clear();
}
inline const ::std::string& AddApplicationRequest::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* AddApplicationRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void AddApplicationRequest::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::add_args() {
  return args_.Add();
}
inline void AddApplicationRequest::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void AddApplicationRequest::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void AddApplicationRequest::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddApplicationRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddApplicationRequest::mutable_args() {
  return &args_;
}

// repeated string envs = 4;
inline int AddApplicationRequest::envs_size() const {
  return envs_.size();
}
inline void AddApplicationRequest::clear_envs() {
  envs_.Clear();
}
inline const ::std::string& AddApplicationRequest::envs(int index) const {
  return envs_.Get(index);
}
inline ::std::string* AddApplicationRequest::mutable_envs(int index) {
  return envs_.Mutable(index);
}
inline void AddApplicationRequest::set_envs(int index, const ::std::string& value) {
  envs_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_envs(int index, const char* value) {
  envs_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_envs(int index, const char* value, size_t size) {
  envs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::add_envs() {
  return envs_.Add();
}
inline void AddApplicationRequest::add_envs(const ::std::string& value) {
  envs_.Add()->assign(value);
}
inline void AddApplicationRequest::add_envs(const char* value) {
  envs_.Add()->assign(value);
}
inline void AddApplicationRequest::add_envs(const char* value, size_t size) {
  envs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddApplicationRequest::envs() const {
  return envs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddApplicationRequest::mutable_envs() {
  return &envs_;
}

// optional bool envs_only = 5 [default = false];
inline bool AddApplicationRequest::has_envs_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddApplicationRequest::set_has_envs_only() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddApplicationRequest::clear_has_envs_only() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddApplicationRequest::clear_envs_only() {
  envs_only_ = false;
  clear_has_envs_only();
}
inline bool AddApplicationRequest::envs_only() const {
  return envs_only_;
}
inline void AddApplicationRequest::set_envs_only(bool value) {
  set_has_envs_only();
  envs_only_ = value;
}

// optional bool redirect_stdout = 6 [default = true];
inline bool AddApplicationRequest::has_redirect_stdout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddApplicationRequest::set_has_redirect_stdout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddApplicationRequest::clear_has_redirect_stdout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddApplicationRequest::clear_redirect_stdout() {
  redirect_stdout_ = true;
  clear_has_redirect_stdout();
}
inline bool AddApplicationRequest::redirect_stdout() const {
  return redirect_stdout_;
}
inline void AddApplicationRequest::set_redirect_stdout(bool value) {
  set_has_redirect_stdout();
  redirect_stdout_ = value;
}

// optional bool redirect_stderr = 7 [default = true];
inline bool AddApplicationRequest::has_redirect_stderr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddApplicationRequest::set_has_redirect_stderr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddApplicationRequest::clear_has_redirect_stderr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddApplicationRequest::clear_redirect_stderr() {
  redirect_stderr_ = true;
  clear_has_redirect_stderr();
}
inline bool AddApplicationRequest::redirect_stderr() const {
  return redirect_stderr_;
}
inline void AddApplicationRequest::set_redirect_stderr(bool value) {
  set_has_redirect_stderr();
  redirect_stderr_ = value;
}

// required string slave_name = 8;
inline bool AddApplicationRequest::has_slave_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AddApplicationRequest::set_has_slave_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AddApplicationRequest::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AddApplicationRequest::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& AddApplicationRequest::slave_name() const {
  return *slave_name_;
}
inline void AddApplicationRequest::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void AddApplicationRequest::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void AddApplicationRequest::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* AddApplicationRequest::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 max_memory_mb = 9 [default = 32768];
inline bool AddApplicationRequest::has_max_memory_mb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AddApplicationRequest::set_has_max_memory_mb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AddApplicationRequest::clear_has_max_memory_mb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AddApplicationRequest::clear_max_memory_mb() {
  max_memory_mb_ = 32768;
  clear_has_max_memory_mb();
}
inline ::google::protobuf::int32 AddApplicationRequest::max_memory_mb() const {
  return max_memory_mb_;
}
inline void AddApplicationRequest::set_max_memory_mb(::google::protobuf::int32 value) {
  set_has_max_memory_mb();
  max_memory_mb_ = value;
}

// optional string comment = 10;
inline bool AddApplicationRequest::has_comment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AddApplicationRequest::set_has_comment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AddApplicationRequest::clear_has_comment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AddApplicationRequest::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& AddApplicationRequest::comment() const {
  return *comment_;
}
inline void AddApplicationRequest::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void AddApplicationRequest::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void AddApplicationRequest::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* AddApplicationRequest::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string md5sum_files = 20;
inline int AddApplicationRequest::md5sum_files_size() const {
  return md5sum_files_.size();
}
inline void AddApplicationRequest::clear_md5sum_files() {
  md5sum_files_.Clear();
}
inline const ::std::string& AddApplicationRequest::md5sum_files(int index) const {
  return md5sum_files_.Get(index);
}
inline ::std::string* AddApplicationRequest::mutable_md5sum_files(int index) {
  return md5sum_files_.Mutable(index);
}
inline void AddApplicationRequest::set_md5sum_files(int index, const ::std::string& value) {
  md5sum_files_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_md5sum_files(int index, const char* value) {
  md5sum_files_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_md5sum_files(int index, const char* value, size_t size) {
  md5sum_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::add_md5sum_files() {
  return md5sum_files_.Add();
}
inline void AddApplicationRequest::add_md5sum_files(const ::std::string& value) {
  md5sum_files_.Add()->assign(value);
}
inline void AddApplicationRequest::add_md5sum_files(const char* value) {
  md5sum_files_.Add()->assign(value);
}
inline void AddApplicationRequest::add_md5sum_files(const char* value, size_t size) {
  md5sum_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddApplicationRequest::md5sum_files() const {
  return md5sum_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddApplicationRequest::mutable_md5sum_files() {
  return &md5sum_files_;
}

// repeated string expected_md5sums = 21;
inline int AddApplicationRequest::expected_md5sums_size() const {
  return expected_md5sums_.size();
}
inline void AddApplicationRequest::clear_expected_md5sums() {
  expected_md5sums_.Clear();
}
inline const ::std::string& AddApplicationRequest::expected_md5sums(int index) const {
  return expected_md5sums_.Get(index);
}
inline ::std::string* AddApplicationRequest::mutable_expected_md5sums(int index) {
  return expected_md5sums_.Mutable(index);
}
inline void AddApplicationRequest::set_expected_md5sums(int index, const ::std::string& value) {
  expected_md5sums_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_expected_md5sums(int index, const char* value) {
  expected_md5sums_.Mutable(index)->assign(value);
}
inline void AddApplicationRequest::set_expected_md5sums(int index, const char* value, size_t size) {
  expected_md5sums_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationRequest::add_expected_md5sums() {
  return expected_md5sums_.Add();
}
inline void AddApplicationRequest::add_expected_md5sums(const ::std::string& value) {
  expected_md5sums_.Add()->assign(value);
}
inline void AddApplicationRequest::add_expected_md5sums(const char* value) {
  expected_md5sums_.Add()->assign(value);
}
inline void AddApplicationRequest::add_expected_md5sums(const char* value, size_t size) {
  expected_md5sums_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddApplicationRequest::expected_md5sums() const {
  return expected_md5sums_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddApplicationRequest::mutable_expected_md5sums() {
  return &expected_md5sums_;
}

// optional bool md5sum_now = 22;
inline bool AddApplicationRequest::has_md5sum_now() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AddApplicationRequest::set_has_md5sum_now() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AddApplicationRequest::clear_has_md5sum_now() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AddApplicationRequest::clear_md5sum_now() {
  md5sum_now_ = false;
  clear_has_md5sum_now();
}
inline bool AddApplicationRequest::md5sum_now() const {
  return md5sum_now_;
}
inline void AddApplicationRequest::set_md5sum_now(bool value) {
  set_has_md5sum_now();
  md5sum_now_ = value;
}

// -------------------------------------------------------------------

// AddApplicationResponse

// optional .cetty.zurg.slave.ApplicationStatus status = 1;
inline bool AddApplicationResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddApplicationResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddApplicationResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddApplicationResponse::clear_status() {
  if (status_ != NULL) status_->::cetty::zurg::slave::ApplicationStatus::Clear();
  clear_has_status();
}
inline const ::cetty::zurg::slave::ApplicationStatus& AddApplicationResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::cetty::zurg::slave::ApplicationStatus* AddApplicationResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::cetty::zurg::slave::ApplicationStatus;
  return status_;
}
inline ::cetty::zurg::slave::ApplicationStatus* AddApplicationResponse::release_status() {
  clear_has_status();
  ::cetty::zurg::slave::ApplicationStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// optional .cetty.zurg.slave.AddApplicationRequest prev_request = 2;
inline bool AddApplicationResponse::has_prev_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddApplicationResponse::set_has_prev_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddApplicationResponse::clear_has_prev_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddApplicationResponse::clear_prev_request() {
  if (prev_request_ != NULL) prev_request_->::cetty::zurg::slave::AddApplicationRequest::Clear();
  clear_has_prev_request();
}
inline const ::cetty::zurg::slave::AddApplicationRequest& AddApplicationResponse::prev_request() const {
  return prev_request_ != NULL ? *prev_request_ : *default_instance_->prev_request_;
}
inline ::cetty::zurg::slave::AddApplicationRequest* AddApplicationResponse::mutable_prev_request() {
  set_has_prev_request();
  if (prev_request_ == NULL) prev_request_ = new ::cetty::zurg::slave::AddApplicationRequest;
  return prev_request_;
}
inline ::cetty::zurg::slave::AddApplicationRequest* AddApplicationResponse::release_prev_request() {
  clear_has_prev_request();
  ::cetty::zurg::slave::AddApplicationRequest* temp = prev_request_;
  prev_request_ = NULL;
  return temp;
}

// repeated string md5sums = 3;
inline int AddApplicationResponse::md5sums_size() const {
  return md5sums_.size();
}
inline void AddApplicationResponse::clear_md5sums() {
  md5sums_.Clear();
}
inline const ::std::string& AddApplicationResponse::md5sums(int index) const {
  return md5sums_.Get(index);
}
inline ::std::string* AddApplicationResponse::mutable_md5sums(int index) {
  return md5sums_.Mutable(index);
}
inline void AddApplicationResponse::set_md5sums(int index, const ::std::string& value) {
  md5sums_.Mutable(index)->assign(value);
}
inline void AddApplicationResponse::set_md5sums(int index, const char* value) {
  md5sums_.Mutable(index)->assign(value);
}
inline void AddApplicationResponse::set_md5sums(int index, const char* value, size_t size) {
  md5sums_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddApplicationResponse::add_md5sums() {
  return md5sums_.Add();
}
inline void AddApplicationResponse::add_md5sums(const ::std::string& value) {
  md5sums_.Add()->assign(value);
}
inline void AddApplicationResponse::add_md5sums(const char* value) {
  md5sums_.Add()->assign(value);
}
inline void AddApplicationResponse::add_md5sums(const char* value, size_t size) {
  md5sums_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddApplicationResponse::md5sums() const {
  return md5sums_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddApplicationResponse::mutable_md5sums() {
  return &md5sums_;
}

// -------------------------------------------------------------------

// StartApplicationsRequest

// repeated string names = 1;
inline int StartApplicationsRequest::names_size() const {
  return names_.size();
}
inline void StartApplicationsRequest::clear_names() {
  names_.Clear();
}
inline const ::std::string& StartApplicationsRequest::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* StartApplicationsRequest::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void StartApplicationsRequest::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void StartApplicationsRequest::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void StartApplicationsRequest::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartApplicationsRequest::add_names() {
  return names_.Add();
}
inline void StartApplicationsRequest::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void StartApplicationsRequest::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void StartApplicationsRequest::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StartApplicationsRequest::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StartApplicationsRequest::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// StartApplicationsResponse

// repeated .cetty.zurg.slave.ApplicationStatus status = 1;
inline int StartApplicationsResponse::status_size() const {
  return status_.size();
}
inline void StartApplicationsResponse::clear_status() {
  status_.Clear();
}
inline const ::cetty::zurg::slave::ApplicationStatus& StartApplicationsResponse::status(int index) const {
  return status_.Get(index);
}
inline ::cetty::zurg::slave::ApplicationStatus* StartApplicationsResponse::mutable_status(int index) {
  return status_.Mutable(index);
}
inline ::cetty::zurg::slave::ApplicationStatus* StartApplicationsResponse::add_status() {
  return status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >&
StartApplicationsResponse::status() const {
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >*
StartApplicationsResponse::mutable_status() {
  return &status_;
}

// -------------------------------------------------------------------

// StopApplicationRequest

// required string names = 1;
inline bool StopApplicationRequest::has_names() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopApplicationRequest::set_has_names() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopApplicationRequest::clear_has_names() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopApplicationRequest::clear_names() {
  if (names_ != &::google::protobuf::internal::kEmptyString) {
    names_->clear();
  }
  clear_has_names();
}
inline const ::std::string& StopApplicationRequest::names() const {
  return *names_;
}
inline void StopApplicationRequest::set_names(const ::std::string& value) {
  set_has_names();
  if (names_ == &::google::protobuf::internal::kEmptyString) {
    names_ = new ::std::string;
  }
  names_->assign(value);
}
inline void StopApplicationRequest::set_names(const char* value) {
  set_has_names();
  if (names_ == &::google::protobuf::internal::kEmptyString) {
    names_ = new ::std::string;
  }
  names_->assign(value);
}
inline void StopApplicationRequest::set_names(const char* value, size_t size) {
  set_has_names();
  if (names_ == &::google::protobuf::internal::kEmptyString) {
    names_ = new ::std::string;
  }
  names_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StopApplicationRequest::mutable_names() {
  set_has_names();
  if (names_ == &::google::protobuf::internal::kEmptyString) {
    names_ = new ::std::string;
  }
  return names_;
}
inline ::std::string* StopApplicationRequest::release_names() {
  clear_has_names();
  if (names_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = names_;
    names_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StopApplicationResponse

// required .cetty.zurg.slave.ApplicationStatus status = 1;
inline bool StopApplicationResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopApplicationResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopApplicationResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopApplicationResponse::clear_status() {
  if (status_ != NULL) status_->::cetty::zurg::slave::ApplicationStatus::Clear();
  clear_has_status();
}
inline const ::cetty::zurg::slave::ApplicationStatus& StopApplicationResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::cetty::zurg::slave::ApplicationStatus* StopApplicationResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::cetty::zurg::slave::ApplicationStatus;
  return status_;
}
inline ::cetty::zurg::slave::ApplicationStatus* StopApplicationResponse::release_status() {
  clear_has_status();
  ::cetty::zurg::slave::ApplicationStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ListApplicationsRequest

// repeated string names = 1;
inline int ListApplicationsRequest::names_size() const {
  return names_.size();
}
inline void ListApplicationsRequest::clear_names() {
  names_.Clear();
}
inline const ::std::string& ListApplicationsRequest::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* ListApplicationsRequest::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void ListApplicationsRequest::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void ListApplicationsRequest::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void ListApplicationsRequest::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListApplicationsRequest::add_names() {
  return names_.Add();
}
inline void ListApplicationsRequest::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void ListApplicationsRequest::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void ListApplicationsRequest::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListApplicationsRequest::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListApplicationsRequest::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// ListApplicationsResponse

// repeated .cetty.zurg.slave.ApplicationStatus status = 1;
inline int ListApplicationsResponse::status_size() const {
  return status_.size();
}
inline void ListApplicationsResponse::clear_status() {
  status_.Clear();
}
inline const ::cetty::zurg::slave::ApplicationStatus& ListApplicationsResponse::status(int index) const {
  return status_.Get(index);
}
inline ::cetty::zurg::slave::ApplicationStatus* ListApplicationsResponse::mutable_status(int index) {
  return status_.Mutable(index);
}
inline ::cetty::zurg::slave::ApplicationStatus* ListApplicationsResponse::add_status() {
  return status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >&
ListApplicationsResponse::status() const {
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::cetty::zurg::slave::ApplicationStatus >*
ListApplicationsResponse::mutable_status() {
  return &status_;
}

// -------------------------------------------------------------------

// RemoveApplicationsRequest

// repeated string name = 1;
inline int RemoveApplicationsRequest::name_size() const {
  return name_.size();
}
inline void RemoveApplicationsRequest::clear_name() {
  name_.Clear();
}
inline const ::std::string& RemoveApplicationsRequest::name(int index) const {
  return name_.Get(index);
}
inline ::std::string* RemoveApplicationsRequest::mutable_name(int index) {
  return name_.Mutable(index);
}
inline void RemoveApplicationsRequest::set_name(int index, const ::std::string& value) {
  name_.Mutable(index)->assign(value);
}
inline void RemoveApplicationsRequest::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
}
inline void RemoveApplicationsRequest::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveApplicationsRequest::add_name() {
  return name_.Add();
}
inline void RemoveApplicationsRequest::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
}
inline void RemoveApplicationsRequest::add_name(const char* value) {
  name_.Add()->assign(value);
}
inline void RemoveApplicationsRequest::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RemoveApplicationsRequest::name() const {
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RemoveApplicationsRequest::mutable_name() {
  return &name_;
}

// -------------------------------------------------------------------

// RemoveApplicationsResponse


// @@protoc_insertion_point(namespace_scope)

}  // namespace slave
}  // namespace zurg
}  // namespace cetty

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< cetty::zurg::slave::ApplicationState>() {
  return cetty::zurg::slave::ApplicationState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cetty_2fzurg_2fslave_2fslave_2eproto__INCLUDED


// Local Variables:
// mode: c++
// End:

