#if !defined(CETTY_HANDLER_CODEC_EMBEDDER_CODECEMBEDDER_H)
#define CETTY_HANDLER_CODEC_EMBEDDER_CODECEMBEDDER_H

/*
 * Copyright 2009 Red Hat, Inc.
 *
 * Red Hat licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
/*
 * Copyright (c) 2010-2011 frankee zhou (frankee.zhou at gmail dot com)
 * Distributed under under the Apache License, version 2.0 (the "License").
 */

#include <cetty/channel/ChannelMessage.h>

namespace cetty {
namespace handler {
namespace codec {
namespace embedder {

using namespace cetty::channel;

/**
 * A helper that wraps an encoder or a decoder (codec) so that they can be used
 * without doing actual I/O in unit tests or higher level codecs.  Please refer
 * to {@link EncoderEmbedder} and {@link DecoderEmbedder} for more information.
 *
 *
 * @author <a href="http://gleamynode.net/">Trustin Lee</a>
 * @author <a href="mailto:frankee.zhou@gmail.com">Frankee Zhou</a>
 */

class CodecEmbedder {
public:
    virtual ~CodecEmbedder() {}

    /**
     * Offers an input object to the pipeline of this embedder.
     *
     * @return <tt>true</tt> if and only if there is something to read in the
     *         product queue (see {@link #poll()} and {@link #peek()})
     */
    virtual bool offer(ChannelMessage& input) = 0;

    /**
     * Signals the pipeline that the encoding or decoding has been finished and
     * no more data will be offered.
     *
     * @return <tt>true</tt> if and only if there is something to read in the
     *         product queue (see {@link #poll()} and {@link #peek()})
     */
    virtual bool finish() = 0;

    /**
     * Consumes an encoded or decoded output from the product queue. The output
     * object is generated by the offered input objects.
     *
     * @return an encoded or decoded object.
     *         <tt>null</tt> if and only if there is no output object left in the
     *         product queue.
     */
    virtual ChannelMessage poll() = 0;

    /**
     * Reads an encoded or decoded output from the head of the product queue.
     * The difference from {@link #poll()} is that it does not remove the
     * retrieved object from the product queue.
     *
     * @return an encoded or decoded object.
     *         <tt>null</tt> if and only if there is no output object left in the
     *         product queue.
     */
    virtual const ChannelMessage& peek() const = 0;

    /**
     * Consumes all encoded or decoded output from the product queue.  The
     * output object is generated by the offered input objects.  The behavior
     * of this method is identical with {@link Collection#toArray()} except that
     * the product queue is cleared.
     *
     * @return an array of all encoded or decoded objects.
     *         An empty array is returned if and only if there is no output
     *         object left in the product queue.
     */
    virtual std::vector<ChannelMessage> pollAll() = 0;

    /**
     * Returns the number of encoded or decoded output in the product queue.
     */
    virtual int size() const = 0;
};


}
}
}
}

#endif //#if !defined(CETTY_HANDLER_CODEC_EMBEDDER_CODECEMBEDDER_H)

// Local Variables:
// mode: c++
// End:

