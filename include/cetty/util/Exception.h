#if !defined(CETTY_UTIL_EXCEPTION_H)
#define CETTY_UTIL_EXCEPTION_H

//
// Exception.h
//
// $Id: //poco/1.4/Foundation/include/Poco/Exception.h#1 $
//
// Library: Foundation
// Package: Core
// Module:  Exception
//
// Definition of various Poco exception classes.
//
// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include <string>
#include <typeinfo>
#include <stdexcept>

namespace cetty {
namespace util {

/**
 * This is the base class for all exceptions defined
 * in the cetty class library.
 */
class Exception: public std::exception {
public:
    /**
     * Creates an exception.
     */
    Exception(const std::string& msg, int code = 0);

    /**
     * Creates an exception.
     */
    Exception(const std::string& msg, const std::string& arg, int code = 0);

    /**
     * Creates an exception and stores a clone of the nested exception.
     */
    Exception(const std::string& msg, const Exception& nested, int code = 0);

    /**
     * Copy constructor.
     */
    Exception(const Exception& exc);

    /**
     * Destroys the exception and deletes the nested exception.
     */
    virtual ~Exception() throw();

    /**
     * Assignment operator.
     */
    Exception& operator = (const Exception& exc);

    /**
     * Returns a static string describing the exception.
     */
    virtual const char* name() const throw();

    /**
     * Returns the name of the exception class.
     */
    virtual const char* className() const throw();

    /**
     * Returns a static string describing the exception.
     * Same as name(), but for compatibility with std::exception.
     */
    virtual const char* what() const throw();

    /**
     * Returns a pointer to the nested exception, or
     * null if no nested exception exists.
     */
    const Exception* nested() const { return nested_; }

    /**
     * Returns the message text.
     */
    const std::string& message() const { return message_; }

    /**
     * Returns the exception code if defined.
     */
    int code() const { return code_; }

    /**
     * Returns a string consisting of the message name and the message text.
     */
    std::string displayText() const;

    /**
     * Creates an exact copy of the exception.
     *
     * The copy can later be thrown again by
     * invoking rethrow() on it.
     */
    virtual Exception* clone() const;

    /**
     * (Re)Throws the exception.
     *
     * This is useful for temporarily storing a
     * copy of an exception (see clone()), then
     *  throwing it again.
     */
    virtual void rethrow() const;

protected:
    Exception(int code = 0);

    void setMessage(const std::string& msg) {
        message_ = msg;
    }

    /**
     * Sets the extended message for the exception.
     */
    void extendedMessage(const std::string& arg);

private:
    int         code_;
    std::string message_;
    Exception*  nested_;
};


//
// Macros for quickly declaring and implementing exception classes.
// Unfortunately, we cannot use a template here because character
// pointers (which we need for specifying the exception name)
// are not allowed as template arguments.
//
#define CETTY_DECLARE_EXCEPTION(CLS, BASE)      \
    class CLS : public BASE {                   \
    public:                                     \
        CLS(int code = 0);                      \
        CLS(const std::string& message,         \
            int code = 0);                      \
        CLS(const std::string& message,         \
            const std::string& arg,             \
            int code = 0);                      \
        CLS(const std::string& message,         \
            const ::cetty::util::Exception& exc,  \
            int code = 0);                      \
        CLS(const CLS& exc);                    \
        virtual ~CLS() throw();                 \
        CLS& operator = (const CLS& exc);       \
        const char* name() const throw();       \
        const char* className() const throw();  \
        ::cetty::util::Exception* clone() const;  \
        void rethrow() const;                   \
    };

#define CETTY_IMPLEMENT_EXCEPTION(CLS, BASE, NAME) \
    CLS::CLS(int code): BASE(code) {}              \
    CLS::CLS(const std::string& message, int code) \
        : BASE(message, code) {}                   \
    CLS::CLS(const std::string& message,           \
             const std::string& arg, int code)     \
        : BASE(message, arg, code) {}              \
    CLS::CLS(const std::string& message,           \
             const cetty::util::Exception& exc,    \
             int code)                             \
        : BASE(message, exc, code) {}              \
    CLS::CLS(const CLS& exc) : BASE(exc) {}        \
    CLS::~CLS() throw() {}                         \
    \
    CLS& CLS::operator = (const CLS& exc) {        \
        BASE::operator = (exc);                    \
        return *this;                              \
    }                                              \
    const char* CLS::name() const throw() {        \
        return NAME;                               \
    }                                              \
    const char* CLS::className() const throw() {   \
        return typeid(*this).name();               \
    }                                              \
    cetty::util::Exception* CLS::clone() const {   \
        return new CLS(*this);                     \
    }                                              \
    void CLS::rethrow() const {                    \
        throw *this;                               \
    }

//
// Standard exception classes
//
CETTY_DECLARE_EXCEPTION(LogicException, Exception)
CETTY_DECLARE_EXCEPTION(AssertionViolationException, LogicException)
CETTY_DECLARE_EXCEPTION(NullPointerException, LogicException)
CETTY_DECLARE_EXCEPTION(NullValueException, LogicException)
CETTY_DECLARE_EXCEPTION(BugcheckException, LogicException)
CETTY_DECLARE_EXCEPTION(InvalidArgumentException, LogicException)
CETTY_DECLARE_EXCEPTION(NotImplementedException, LogicException)
CETTY_DECLARE_EXCEPTION(UnsupportedOperationException, LogicException)
CETTY_DECLARE_EXCEPTION(RangeException, LogicException)
CETTY_DECLARE_EXCEPTION(IllegalStateException, LogicException)
CETTY_DECLARE_EXCEPTION(NumberFormatException, LogicException)
CETTY_DECLARE_EXCEPTION(InvalidAccessException, LogicException)
CETTY_DECLARE_EXCEPTION(SignalException, LogicException)
CETTY_DECLARE_EXCEPTION(UnhandledException, LogicException)

CETTY_DECLARE_EXCEPTION(RuntimeException, Exception)
CETTY_DECLARE_EXCEPTION(NotFoundException, RuntimeException)
CETTY_DECLARE_EXCEPTION(ExistsException, RuntimeException)
CETTY_DECLARE_EXCEPTION(TimeoutException, RuntimeException)
CETTY_DECLARE_EXCEPTION(SystemException, RuntimeException)
CETTY_DECLARE_EXCEPTION(RegularExpressionException, RuntimeException)
CETTY_DECLARE_EXCEPTION(LibraryLoadException, RuntimeException)
CETTY_DECLARE_EXCEPTION(LibraryAlreadyLoadedException, RuntimeException)
CETTY_DECLARE_EXCEPTION(NoThreadAvailableException, RuntimeException)
CETTY_DECLARE_EXCEPTION(NotYetConnectedException, RuntimeException)
CETTY_DECLARE_EXCEPTION(InterruptedException, RuntimeException)
CETTY_DECLARE_EXCEPTION(PropertyNotSupportedException, RuntimeException)
CETTY_DECLARE_EXCEPTION(PoolOverflowException, RuntimeException)
CETTY_DECLARE_EXCEPTION(NoPermissionException, RuntimeException)
CETTY_DECLARE_EXCEPTION(OutOfMemoryException, RuntimeException)
CETTY_DECLARE_EXCEPTION(DataException, RuntimeException)

CETTY_DECLARE_EXCEPTION(DataFormatException, DataException)
CETTY_DECLARE_EXCEPTION(SyntaxException, DataException)
CETTY_DECLARE_EXCEPTION(CircularReferenceException, DataException)
CETTY_DECLARE_EXCEPTION(PathSyntaxException, SyntaxException)
CETTY_DECLARE_EXCEPTION(IOException, RuntimeException)
CETTY_DECLARE_EXCEPTION(ProtocolException, IOException)
CETTY_DECLARE_EXCEPTION(FileException, IOException)
CETTY_DECLARE_EXCEPTION(FileExistsException, FileException)
CETTY_DECLARE_EXCEPTION(FileNotFoundException, FileException)
CETTY_DECLARE_EXCEPTION(PathNotFoundException, FileException)
CETTY_DECLARE_EXCEPTION(FileReadOnlyException, FileException)
CETTY_DECLARE_EXCEPTION(FileAccessDeniedException, FileException)
CETTY_DECLARE_EXCEPTION(CreateFileException, FileException)
CETTY_DECLARE_EXCEPTION(OpenFileException, FileException)
CETTY_DECLARE_EXCEPTION(WriteFileException, FileException)
CETTY_DECLARE_EXCEPTION(ReadFileException, FileException)
CETTY_DECLARE_EXCEPTION(UnknownURISchemeException, RuntimeException)

CETTY_DECLARE_EXCEPTION(ApplicationException, Exception)
CETTY_DECLARE_EXCEPTION(BadCastException, RuntimeException)

}
}

#endif //#if !defined(CETTY_UTIL_EXCEPTION_H)

// Local Variables:
// mode: c++
// End:
