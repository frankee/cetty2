package cetty.service.builder;

import "cetty/config/config_options.proto";

option (config_file_options).config_file_name = "";
option (config_file_options).source_file_name = "";

message ServerConfig {
}

message ServerBuilderConfig {
	message Server {
		//option (config_message_options).template = "{host}:{port}";
		
		// # If you want you can bind a single interface, if the bind option is not
		// # specified all the interfaces will listen for incoming connections.
		// # host: 
		optional string host = 1;
		
		// # Accept connections on the specified port.
		required int32  port = 2;
		
		optional ServerConfig config = 3;
	}
	
	message Limit {
		required int32 maxConcurrentRequests = 1 [default=10000];
	}
	
	message Timeout {
		required int32 hostConnectionMaxIdleTime = 1[default=1800];
	}
	
	message Logger {
		optional string logger = 1;
		optional string  level = 2;
	}
	
	// # By default cetty does not run as a daemon. Use 'true' if you need it.
	// # Note that cetty will write a pid file in /var/run/xxx.pid when daemonized.
	// # daemonize : true
	required bool daemonize = 1 [
		(config_options).cmd       = "daemon",
		(config_options).short_cmd = "d"];

	// # When running daemonized, Cetty does not write a pid file by 
	// # default. You can specify a pid file location here if needed.
	// # pidfile: /var/run/your.pid
    optional string pidfile = 2;
	
    required int32 parent_thread_count = 4 [default = 1];
    required int32  child_thread_count = 5 [default = 0];
    required int32             backlog = 6 [default = 4096];
    
	optional Logger   logger = 7;

    optional Limit     limit = 8;
    optional Timeout timeout = 9;

	// # examples like:
	// # servers:
	// #   your-server-app:
	// #     port: 8080
	// #     host: 192.168.1.188
	// #   another-server-app:
	// #     port: 8888
	// # 
    repeated Server servers  = 10 [
		(config_options).map = true,
		(config_options).default = "{{http:\":8080\"}, {rpc:\":18080\"}}"
	];
}
