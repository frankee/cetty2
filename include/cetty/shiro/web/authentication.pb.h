// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cetty/shiro/web/authentication.proto

#ifndef PROTOBUF_cetty_2fshiro_2fweb_2fauthentication_2eproto__INCLUDED
#define PROTOBUF_cetty_2fshiro_2fweb_2fauthentication_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <cetty/protobuf/service/ProtobufService.h>
#include <cetty/protobuf/service/ProtobufServiceFuture.h>
#include <cetty/protobuf/service/ProtobufServiceMessagePtr.h>
#include <cetty/protobuf/service/ProtobufClientServiceAdaptor.h>
#include "cetty/protobuf/service/common.pb.h"
// @@protoc_insertion_point(includes)

namespace cetty {
namespace shiro {
namespace web {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();

class PreLoginRequest;
class PreLoginResponse;
class LoginRequest;
class LoginResponse;
class LogoutRequest;
class LogoutResponse;

// ===================================================================

class PreLoginRequest : public ::google::protobuf::Message {
 public:
  PreLoginRequest();
  virtual ~PreLoginRequest();
  
  PreLoginRequest(const PreLoginRequest& from);
  
  inline PreLoginRequest& operator=(const PreLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreLoginRequest& default_instance();
  
  void Swap(PreLoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  PreLoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreLoginRequest& from);
  void MergeFrom(const PreLoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  
  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  
  // @@protoc_insertion_point(class_scope:cetty.shiro.web.PreLoginRequest)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* host_;
  ::std::string* user_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  
  void InitAsDefaultInstance();
  static PreLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class PreLoginResponse : public ::google::protobuf::Message {
 public:
  PreLoginResponse();
  virtual ~PreLoginResponse();
  
  PreLoginResponse(const PreLoginResponse& from);
  
  inline PreLoginResponse& operator=(const PreLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreLoginResponse& default_instance();
  
  void Swap(PreLoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  PreLoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreLoginResponse& from);
  void MergeFrom(const PreLoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .cetty.protobuf.service.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::protobuf::service::Status& status() const;
  inline ::cetty::protobuf::service::Status* mutable_status();
  inline ::cetty::protobuf::service::Status* release_status();
  
  // optional .cetty.protobuf.service.Session session = 2;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::cetty::protobuf::service::Session& session() const;
  inline ::cetty::protobuf::service::Session* mutable_session();
  inline ::cetty::protobuf::service::Session* release_session();
  
  // optional string nonce = 3;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 3;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const char* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  
  // optional string server_time = 4;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 4;
  inline const ::std::string& server_time() const;
  inline void set_server_time(const ::std::string& value);
  inline void set_server_time(const char* value);
  inline void set_server_time(const char* value, size_t size);
  inline ::std::string* mutable_server_time();
  inline ::std::string* release_server_time();
  
  // @@protoc_insertion_point(class_scope:cetty.shiro.web.PreLoginResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_server_time();
  inline void clear_has_server_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cetty::protobuf::service::Status* status_;
  ::cetty::protobuf::service::Session* session_;
  ::std::string* nonce_;
  ::std::string* server_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  
  void InitAsDefaultInstance();
  static PreLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  
  // optional string nonce = 2;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 2;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const char* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  
  // optional string server_time = 3;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 3;
  inline const ::std::string& server_time() const;
  inline void set_server_time(const ::std::string& value);
  inline void set_server_time(const char* value);
  inline void set_server_time(const char* value, size_t size);
  inline ::std::string* mutable_server_time();
  inline ::std::string* release_server_time();
  
  // optional string encode_type = 8;
  inline bool has_encode_type() const;
  inline void clear_encode_type();
  static const int kEncodeTypeFieldNumber = 8;
  inline const ::std::string& encode_type() const;
  inline void set_encode_type(const ::std::string& value);
  inline void set_encode_type(const char* value);
  inline void set_encode_type(const char* value, size_t size);
  inline ::std::string* mutable_encode_type();
  inline ::std::string* release_encode_type();
  
  // optional string encoded_passwd = 9;
  inline bool has_encoded_passwd() const;
  inline void clear_encoded_passwd();
  static const int kEncodedPasswdFieldNumber = 9;
  inline const ::std::string& encoded_passwd() const;
  inline void set_encoded_passwd(const ::std::string& value);
  inline void set_encoded_passwd(const char* value);
  inline void set_encoded_passwd(const char* value, size_t size);
  inline ::std::string* mutable_encoded_passwd();
  inline ::std::string* release_encoded_passwd();
  
  // @@protoc_insertion_point(class_scope:cetty.shiro.web.LoginRequest)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_server_time();
  inline void clear_has_server_time();
  inline void set_has_encode_type();
  inline void clear_has_encode_type();
  inline void set_has_encoded_passwd();
  inline void clear_has_encoded_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_name_;
  ::std::string* nonce_;
  ::std::string* server_time_;
  ::std::string* encode_type_;
  ::std::string* encoded_passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();
  
  LoginResponse(const LoginResponse& from);
  
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();
  
  void Swap(LoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .cetty.protobuf.service.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::protobuf::service::Status& status() const;
  inline ::cetty::protobuf::service::Status* mutable_status();
  inline ::cetty::protobuf::service::Status* release_status();
  
  // optional .cetty.protobuf.service.Session session = 2;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::cetty::protobuf::service::Session& session() const;
  inline ::cetty::protobuf::service::Session* mutable_session();
  inline ::cetty::protobuf::service::Session* release_session();
  
  // @@protoc_insertion_point(class_scope:cetty.shiro.web.LoginResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_session();
  inline void clear_has_session();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cetty::protobuf::service::Status* status_;
  ::cetty::protobuf::service::Session* session_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();
  
  LogoutRequest(const LogoutRequest& from);
  
  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();
  
  void Swap(LogoutRequest* other);
  
  // implements Message ----------------------------------------------
  
  LogoutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .cetty.protobuf.service.Session session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::cetty::protobuf::service::Session& session() const;
  inline ::cetty::protobuf::service::Session* mutable_session();
  inline ::cetty::protobuf::service::Session* release_session();
  
  // @@protoc_insertion_point(class_scope:cetty.shiro.web.LogoutRequest)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cetty::protobuf::service::Session* session_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResponse : public ::google::protobuf::Message {
 public:
  LogoutResponse();
  virtual ~LogoutResponse();
  
  LogoutResponse(const LogoutResponse& from);
  
  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponse& default_instance();
  
  void Swap(LogoutResponse* other);
  
  // implements Message ----------------------------------------------
  
  LogoutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResponse& from);
  void MergeFrom(const LogoutResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .cetty.protobuf.service.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::cetty::protobuf::service::Status& status() const;
  inline ::cetty::protobuf::service::Status* mutable_status();
  inline ::cetty::protobuf::service::Status* release_status();
  
  // @@protoc_insertion_point(class_scope:cetty.shiro.web.LogoutResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cetty::protobuf::service::Status* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_cetty_2fshiro_2fweb_2fauthentication_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutResponse* default_instance_;
};
// ===================================================================

class AuthenticationService_Stub;

typedef ::cetty::shiro::web::PreLoginRequest* PreLoginRequestPtr;
typedef ::cetty::shiro::web::PreLoginRequest const* ConstPreLoginRequestPtr;
typedef ::cetty::shiro::web::PreLoginResponse* PreLoginResponsePtr;
typedef ::cetty::service::ServiceFuture<PreLoginResponsePtr> preLoginServiceFuture;
typedef boost::intrusive_ptr<preLoginServiceFuture> preLoginServiceFuturePtr;
typedef ::cetty::shiro::web::LoginRequest* LoginRequestPtr;
typedef ::cetty::shiro::web::LoginRequest const* ConstLoginRequestPtr;
typedef ::cetty::shiro::web::LoginResponse* LoginResponsePtr;
typedef ::cetty::service::ServiceFuture<LoginResponsePtr> loginServiceFuture;
typedef boost::intrusive_ptr<loginServiceFuture> loginServiceFuturePtr;
typedef ::cetty::shiro::web::LogoutRequest* LogoutRequestPtr;
typedef ::cetty::shiro::web::LogoutRequest const* ConstLogoutRequestPtr;
typedef ::cetty::shiro::web::LogoutResponse* LogoutResponsePtr;
typedef ::cetty::service::ServiceFuture<LogoutResponsePtr> logoutServiceFuture;
typedef boost::intrusive_ptr<logoutServiceFuture> logoutServiceFuturePtr;

class AuthenticationService : public ::cetty::protobuf::service::ProtobufService {
 protected:
  // This class should be treated as an abstract interface.
  inline AuthenticationService() {};
 public:
  virtual ~AuthenticationService();
  
  typedef AuthenticationService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void preLogin(const ConstPreLoginRequestPtr& request,
                       const PreLoginResponsePtr& response,
                       const DoneCallback& done);
  virtual void login(const ConstLoginRequestPtr& request,
                       const LoginResponsePtr& response,
                       const DoneCallback& done);
  virtual void logout(const ConstLogoutRequestPtr& request,
                       const LogoutResponsePtr& response,
                       const DoneCallback& done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  const ::cetty::protobuf::service::ConstMessagePtr& request,
                  const ::cetty::protobuf::service::MessagePtr& response,
                  const DoneCallback& done);
  
  const ::google::protobuf::Message* GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message* GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationService);
};

class AuthenticationService_Stub : public AuthenticationService {
 public:
  AuthenticationService_Stub(const ::cetty::service::ClientServicePtr& service);
  ~AuthenticationService_Stub();
  
  inline const ::cetty::service::ClientServicePtr& channel() {
      return channel_.getService();
  }
  
  // implements AuthenticationService ------------------------------------------
  
  using AuthenticationService::preLogin;
  virtual void preLogin(const ConstPreLoginRequestPtr& request,
                       const preLoginServiceFuturePtr& future);
  using AuthenticationService::login;
  virtual void login(const ConstLoginRequestPtr& request,
                       const loginServiceFuturePtr& future);
  using AuthenticationService::logout;
  virtual void logout(const ConstLogoutRequestPtr& request,
                       const logoutServiceFuturePtr& future);
 private:
  cetty::protobuf::service::ProtobufClientServiceAdaptor channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationService_Stub);
};


// ===================================================================


// ===================================================================

// PreLoginRequest

// required string host = 1;
inline bool PreLoginRequest::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreLoginRequest::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreLoginRequest::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreLoginRequest::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& PreLoginRequest::host() const {
  return *host_;
}
inline void PreLoginRequest::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void PreLoginRequest::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void PreLoginRequest::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreLoginRequest::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* PreLoginRequest::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user_name = 2;
inline bool PreLoginRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreLoginRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreLoginRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreLoginRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& PreLoginRequest::user_name() const {
  return *user_name_;
}
inline void PreLoginRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void PreLoginRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void PreLoginRequest::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreLoginRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* PreLoginRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PreLoginResponse

// optional .cetty.protobuf.service.Status status = 1;
inline bool PreLoginResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreLoginResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreLoginResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreLoginResponse::clear_status() {
  if (status_ != NULL) status_->::cetty::protobuf::service::Status::Clear();
  clear_has_status();
}
inline const ::cetty::protobuf::service::Status& PreLoginResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::cetty::protobuf::service::Status* PreLoginResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::cetty::protobuf::service::Status;
  return status_;
}
inline ::cetty::protobuf::service::Status* PreLoginResponse::release_status() {
  clear_has_status();
  ::cetty::protobuf::service::Status* temp = status_;
  status_ = NULL;
  return temp;
}

// optional .cetty.protobuf.service.Session session = 2;
inline bool PreLoginResponse::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreLoginResponse::set_has_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreLoginResponse::clear_has_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreLoginResponse::clear_session() {
  if (session_ != NULL) session_->::cetty::protobuf::service::Session::Clear();
  clear_has_session();
}
inline const ::cetty::protobuf::service::Session& PreLoginResponse::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::cetty::protobuf::service::Session* PreLoginResponse::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::cetty::protobuf::service::Session;
  return session_;
}
inline ::cetty::protobuf::service::Session* PreLoginResponse::release_session() {
  clear_has_session();
  ::cetty::protobuf::service::Session* temp = session_;
  session_ = NULL;
  return temp;
}

// optional string nonce = 3;
inline bool PreLoginResponse::has_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreLoginResponse::set_has_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreLoginResponse::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreLoginResponse::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& PreLoginResponse::nonce() const {
  return *nonce_;
}
inline void PreLoginResponse::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void PreLoginResponse::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void PreLoginResponse::set_nonce(const char* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreLoginResponse::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* PreLoginResponse::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string server_time = 4;
inline bool PreLoginResponse::has_server_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreLoginResponse::set_has_server_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreLoginResponse::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreLoginResponse::clear_server_time() {
  if (server_time_ != &::google::protobuf::internal::kEmptyString) {
    server_time_->clear();
  }
  clear_has_server_time();
}
inline const ::std::string& PreLoginResponse::server_time() const {
  return *server_time_;
}
inline void PreLoginResponse::set_server_time(const ::std::string& value) {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  server_time_->assign(value);
}
inline void PreLoginResponse::set_server_time(const char* value) {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  server_time_->assign(value);
}
inline void PreLoginResponse::set_server_time(const char* value, size_t size) {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  server_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreLoginResponse::mutable_server_time() {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  return server_time_;
}
inline ::std::string* PreLoginResponse::release_server_time() {
  clear_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_time_;
    server_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginRequest

// optional string user_name = 1;
inline bool LoginRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginRequest::user_name() const {
  return *user_name_;
}
inline void LoginRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginRequest::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nonce = 2;
inline bool LoginRequest::has_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& LoginRequest::nonce() const {
  return *nonce_;
}
inline void LoginRequest::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void LoginRequest::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void LoginRequest::set_nonce(const char* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* LoginRequest::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string server_time = 3;
inline bool LoginRequest::has_server_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_server_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_server_time() {
  if (server_time_ != &::google::protobuf::internal::kEmptyString) {
    server_time_->clear();
  }
  clear_has_server_time();
}
inline const ::std::string& LoginRequest::server_time() const {
  return *server_time_;
}
inline void LoginRequest::set_server_time(const ::std::string& value) {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  server_time_->assign(value);
}
inline void LoginRequest::set_server_time(const char* value) {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  server_time_->assign(value);
}
inline void LoginRequest::set_server_time(const char* value, size_t size) {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  server_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_server_time() {
  set_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    server_time_ = new ::std::string;
  }
  return server_time_;
}
inline ::std::string* LoginRequest::release_server_time() {
  clear_has_server_time();
  if (server_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_time_;
    server_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string encode_type = 8;
inline bool LoginRequest::has_encode_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_encode_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_encode_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_encode_type() {
  if (encode_type_ != &::google::protobuf::internal::kEmptyString) {
    encode_type_->clear();
  }
  clear_has_encode_type();
}
inline const ::std::string& LoginRequest::encode_type() const {
  return *encode_type_;
}
inline void LoginRequest::set_encode_type(const ::std::string& value) {
  set_has_encode_type();
  if (encode_type_ == &::google::protobuf::internal::kEmptyString) {
    encode_type_ = new ::std::string;
  }
  encode_type_->assign(value);
}
inline void LoginRequest::set_encode_type(const char* value) {
  set_has_encode_type();
  if (encode_type_ == &::google::protobuf::internal::kEmptyString) {
    encode_type_ = new ::std::string;
  }
  encode_type_->assign(value);
}
inline void LoginRequest::set_encode_type(const char* value, size_t size) {
  set_has_encode_type();
  if (encode_type_ == &::google::protobuf::internal::kEmptyString) {
    encode_type_ = new ::std::string;
  }
  encode_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_encode_type() {
  set_has_encode_type();
  if (encode_type_ == &::google::protobuf::internal::kEmptyString) {
    encode_type_ = new ::std::string;
  }
  return encode_type_;
}
inline ::std::string* LoginRequest::release_encode_type() {
  clear_has_encode_type();
  if (encode_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encode_type_;
    encode_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string encoded_passwd = 9;
inline bool LoginRequest::has_encoded_passwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_encoded_passwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_encoded_passwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_encoded_passwd() {
  if (encoded_passwd_ != &::google::protobuf::internal::kEmptyString) {
    encoded_passwd_->clear();
  }
  clear_has_encoded_passwd();
}
inline const ::std::string& LoginRequest::encoded_passwd() const {
  return *encoded_passwd_;
}
inline void LoginRequest::set_encoded_passwd(const ::std::string& value) {
  set_has_encoded_passwd();
  if (encoded_passwd_ == &::google::protobuf::internal::kEmptyString) {
    encoded_passwd_ = new ::std::string;
  }
  encoded_passwd_->assign(value);
}
inline void LoginRequest::set_encoded_passwd(const char* value) {
  set_has_encoded_passwd();
  if (encoded_passwd_ == &::google::protobuf::internal::kEmptyString) {
    encoded_passwd_ = new ::std::string;
  }
  encoded_passwd_->assign(value);
}
inline void LoginRequest::set_encoded_passwd(const char* value, size_t size) {
  set_has_encoded_passwd();
  if (encoded_passwd_ == &::google::protobuf::internal::kEmptyString) {
    encoded_passwd_ = new ::std::string;
  }
  encoded_passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_encoded_passwd() {
  set_has_encoded_passwd();
  if (encoded_passwd_ == &::google::protobuf::internal::kEmptyString) {
    encoded_passwd_ = new ::std::string;
  }
  return encoded_passwd_;
}
inline ::std::string* LoginRequest::release_encoded_passwd() {
  clear_has_encoded_passwd();
  if (encoded_passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_passwd_;
    encoded_passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginResponse

// optional .cetty.protobuf.service.Status status = 1;
inline bool LoginResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_status() {
  if (status_ != NULL) status_->::cetty::protobuf::service::Status::Clear();
  clear_has_status();
}
inline const ::cetty::protobuf::service::Status& LoginResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::cetty::protobuf::service::Status* LoginResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::cetty::protobuf::service::Status;
  return status_;
}
inline ::cetty::protobuf::service::Status* LoginResponse::release_status() {
  clear_has_status();
  ::cetty::protobuf::service::Status* temp = status_;
  status_ = NULL;
  return temp;
}

// optional .cetty.protobuf.service.Session session = 2;
inline bool LoginResponse::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_session() {
  if (session_ != NULL) session_->::cetty::protobuf::service::Session::Clear();
  clear_has_session();
}
inline const ::cetty::protobuf::service::Session& LoginResponse::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::cetty::protobuf::service::Session* LoginResponse::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::cetty::protobuf::service::Session;
  return session_;
}
inline ::cetty::protobuf::service::Session* LoginResponse::release_session() {
  clear_has_session();
  ::cetty::protobuf::service::Session* temp = session_;
  session_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LogoutRequest

// optional .cetty.protobuf.service.Session session = 1;
inline bool LogoutRequest::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRequest::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutRequest::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutRequest::clear_session() {
  if (session_ != NULL) session_->::cetty::protobuf::service::Session::Clear();
  clear_has_session();
}
inline const ::cetty::protobuf::service::Session& LogoutRequest::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::cetty::protobuf::service::Session* LogoutRequest::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::cetty::protobuf::service::Session;
  return session_;
}
inline ::cetty::protobuf::service::Session* LogoutRequest::release_session() {
  clear_has_session();
  ::cetty::protobuf::service::Session* temp = session_;
  session_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LogoutResponse

// optional .cetty.protobuf.service.Status status = 1;
inline bool LogoutResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutResponse::clear_status() {
  if (status_ != NULL) status_->::cetty::protobuf::service::Status::Clear();
  clear_has_status();
}
inline const ::cetty::protobuf::service::Status& LogoutResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::cetty::protobuf::service::Status* LogoutResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::cetty::protobuf::service::Status;
  return status_;
}
inline ::cetty::protobuf::service::Status* LogoutResponse::release_status() {
  clear_has_status();
  ::cetty::protobuf::service::Status* temp = status_;
  status_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace web
}  // namespace shiro
}  // namespace cetty

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cetty_2fshiro_2fweb_2fauthentication_2eproto__INCLUDED


// Local Variables:
// mode: c++
// End:

