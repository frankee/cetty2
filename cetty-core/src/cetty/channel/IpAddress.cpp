//
// IpAddress.cpp
//
// $Id: //poco/1.4/Net/src/IpAddress.cpp#1 $
//
// Library: Net
// Package: NetCore
// Module:  IpAddress
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
/*
 * Copyright (c) 2010-2011 frankee zhou (frankee.zhou at gmail dot com)
 * Distributed under under the Apache License, version 2.0 (the "License").
 */

#include <cetty/channel/IpAddress.h>
#include <cetty/channel/IpAddressImpl.h>

namespace cetty {
namespace channel {

IpAddressImplFactory* IpAddress::factory = NULL;
const cetty::channel::IpAddress IpAddress::NULL_ADDRESS;

IpAddress::IpAddress() {
}

IpAddress::IpAddress(const SmartPointer& impl) : impl(impl) {
}

IpAddress::IpAddress(const IpAddress& addr): impl(addr.impl) {
}

IpAddress::IpAddress(int family) {
    if (factory) { impl = SmartPointer(factory->create(family)); }
}

IpAddress::IpAddress(const std::string& addr) {
    if (factory) { impl = SmartPointer(factory->create(addr)); }
}

IpAddress::IpAddress(const std::string& addr, int family) {
    if (factory) { impl = SmartPointer(factory->create(addr, family)); }
}

IpAddress::~IpAddress() {
}

IpAddress& IpAddress::operator = (const IpAddress& addr) {
    if (&addr != this) {
        impl = addr.impl;
    }

    return *this;
}

void IpAddress::swap(IpAddress& address) {
    impl.swap(address.impl);
}

int IpAddress::family() const {
    if (!impl) { return IPv4; }

    return impl->family();
}

std::string IpAddress::toString() const {
    if (impl) { return impl->toString(); }

    return "NULL_ADDRESS";
}

bool IpAddress::isWildcard() const {
    if (impl) { return impl->isWildcard(); }

    return false;
}

bool IpAddress::isBroadcast() const {
    if (impl) { return impl->isBroadcast(); }

    return false;
}

bool IpAddress::isLoopback() const {
    if (impl) { return impl->isLoopback(); }

    return false;
}

bool IpAddress::isMulticast() const {
    if (impl) { return impl->isMulticast(); }

    return false;
}

bool IpAddress::isUnicast() const {
    if (impl) { return !isWildcard() && !isBroadcast() && !isMulticast(); }

    return false;
}

bool IpAddress::isLinkLocal() const {
    if (impl) { return impl->isLinkLocal(); }

    return false;
}

bool IpAddress::isSiteLocal() const {
    if (impl) { return impl->isSiteLocal(); }

    return false;
}

bool IpAddress::isIPv4Compatible() const {
    if (impl) {
        return impl->isIPv4Compatible();
    }

    return true;
}

bool IpAddress::isIPv4Mapped() const {
    if (impl) {
        return impl->isIPv4Mapped();
    }

    return false;
}

bool IpAddress::isWellKnownMC() const {
    if (impl) { return impl->isWellKnownMC(); }

    return false;
}

bool IpAddress::isNodeLocalMC() const {
    if (impl) { return impl->isNodeLocalMC(); }

    return false;
}

bool IpAddress::isLinkLocalMC() const {
    if (impl) { return impl->isLinkLocalMC(); }

    return false;
}

bool IpAddress::isSiteLocalMC() const {
    if (impl) { return impl->isSiteLocalMC(); }

    return false;
}

bool IpAddress::isOrgLocalMC() const {
    if (impl) { return impl->isOrgLocalMC(); }

    return false;
}

bool IpAddress::isGlobalMC() const {
    if (impl) { return impl->isGlobalMC(); }

    return false;
}

bool IpAddress::operator == (const IpAddress& a) const {
    if (&a == this) { return true; }

    if (impl) {
        if (a.impl) {
            return impl->equals(*a.impl);
        }
        else {
            return false;
        }
    }
    else {
        if (a.impl) {
            return false;
        }
        else {
            return true;
        }
    }
}

bool IpAddress::operator != (const IpAddress& a) const {
    return !((*this) == a);
}

bool IpAddress::operator < (const IpAddress& a) const {
    if (&a == this) { return false; }

    if (impl) {
        if (a.impl) {
            return impl->compareTo(*a.impl) < 0;
        }
        else {
            return false;
        }
    }
    else {
        if (a.impl) {
            return true;
        }
        else {
            return false;
        }
    }
}

bool IpAddress::operator <= (const IpAddress& a) const {
    if (&a == this) { return true; }

    if (!impl) {
        return true;
    }

    if (!a.impl) {
        return false;
    }

    return impl->compareTo(*a.impl) <= 0;
}

bool IpAddress::operator > (const IpAddress& a) const {
    return !((*this) <= a);
}

bool IpAddress::operator >= (const IpAddress& a) const {
    return !((*this) < a);
}

IpAddress IpAddress::parse(const std::string& addr) {
    return IpAddress(addr);
}

bool IpAddress::tryParse(const std::string& addr, IpAddress& result) {
    return false;
}

void IpAddress::mask(const IpAddress& mask) {
    //  IpAddressImpl* pClone = impl->clone();
    //  impl->release();
    //  impl = pClone;
    //  IpAddress null;
    //  impl->mask(mask._pImpl, null._pImpl);
}

void IpAddress::mask(const IpAddress& mask, const IpAddress& set) {
    //  IpAddressImpl* pClone = impl->clone();
    //  impl->release();
    //  impl = pClone;
    //  impl->mask(mask._pImpl, set._pImpl);
}

IpAddress IpAddress::wildcard(int family) {
    return IpAddress(family);
}

IpAddress IpAddress::broadcast() {
    return IpAddress("255.255.255.255");
}

void IpAddress::setFactory(IpAddressImplFactory* factory) {
    IpAddress::factory = factory;
}

void IpAddress::resetFactory() {

}

bool IpAddress::hasFactory() {
    return NULL != IpAddress::factory;
}

}
}
