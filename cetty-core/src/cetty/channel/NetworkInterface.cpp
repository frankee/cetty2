//
// NetworkInterface.cpp
//
// $Id: //poco/1.4/Net/src/NetworkInterface.cpp#1 $
//
// Library: Net
// Package: Sockets
// Module:  NetworkInterface
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute ,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
/*
 * Copyright (c) 2010-2011 frankee zhou (frankee.zhou at gmail dot com)
 * Distributed under under the Apache License, version 2.0 (the "License").
 */

#include <cetty/channel/IpAddress.h>
#include <cetty/channel/NetworkInterface.h>

namespace cetty {
namespace channel {

class NetworkInterfaceImpl {
public:
    NetworkInterfaceImpl() : index(-1) {}

    NetworkInterfaceImpl(const std::string& name,
                         const std::string& displayName,
                         const IpAddress& address,
                         int index = -1) :
        name(name),
        displayName(displayName),
        address(address),
        index(index) {

#if 0//!BOOST_WINDOWS

        if (index == -1) { // IPv4
            struct ifreq ifr;
            std::strncpy(ifr.ifr_name, name.c_str(), IFNAMSIZ);
            DatagramSocket ds(IPAddress::IPv4);
            ds.impl()->ioctl(SIOCGIFNETMASK, &ifr);

            if (ifr.ifr_addr.sa_family == AF_INET) {
                subnetMask = IPAddress(&reinterpret_cast<const struct sockaddr_in*>(&ifr.ifr_addr)->sin_addr, sizeof(struct in_addr));
            }

            if (!address.isLoopback()) {
                try {
                    // Not every interface (e.g. loopback) has a broadcast address
                    ds.impl()->ioctl(SIOCGIFBRDADDR, &ifr);

                    if (ifr.ifr_addr.sa_family == AF_INET) {
                        broadcastAddress = IPAddress(&reinterpret_cast<const struct sockaddr_in*>(&ifr.ifr_addr)->sin_addr, sizeof(struct in_addr));
                    }
                }
                catch (...) {
                }
            }
        }

#endif
    }

    NetworkInterfaceImpl(const std::string& name,
                         const std::string& displayName,
                         const IpAddress& address,
                         const IpAddress& subnetMask,
                         const IpAddress& broadcastAddress,
                         int index = -1) :
        name(name),
        displayName(displayName),
        address(address),
        subnetMask(subnetMask),
        broadcastAddress(broadcastAddress),
        index(index) {
    }

    int getIndex() const { return index; }
    const std::string& getName() const { return name; }
    const std::string& getDisplayName() const { return displayName; }
    const IpAddress& getAddress() const { return address; }
    const IpAddress& getSubnetMask() const { return subnetMask; }
    const IpAddress& getBroadcastAddress() const { return broadcastAddress; }

    bool equals(const NetworkInterfaceImpl& impl) {
        return name == impl.name && address == impl.address && index == impl.index;
    }

    ~NetworkInterfaceImpl() {}

private:
    std::string name;
    std::string displayName;
    IpAddress   address;
    IpAddress   subnetMask;
    IpAddress   broadcastAddress;
    int         index;
};

const NetworkInterface NetworkInterface::NULL_INTERFACE;

NetworkInterface::NetworkInterface() {}

NetworkInterface::NetworkInterface(const NetworkInterface& interfc)
    : impl(interfc.impl) {
}

NetworkInterface::NetworkInterface(const std::string& name,
                                   const std::string& displayName,
                                   const IpAddress& address,
                                   int index) :
    impl(SharedPtr(new NetworkInterfaceImpl(name, displayName, address, index))) {
}

NetworkInterface::NetworkInterface(const std::string& name,
                                   const std::string& displayName,
                                   const IpAddress& address,
                                   const IpAddress& subnetMask,
                                   const IpAddress& broadcastAddress,
                                   int index):
    impl(SharedPtr(new NetworkInterfaceImpl(name, displayName, address, subnetMask, broadcastAddress, index))) {
}

NetworkInterface::NetworkInterface(const std::string& name,
                                   const IpAddress& address,
                                   int index):
    impl(SharedPtr(new NetworkInterfaceImpl(name, name, address, index))) {
}

NetworkInterface::NetworkInterface(const std::string& name,
                                   const IpAddress& address,
                                   const IpAddress& subnetMask,
                                   const IpAddress& broadcastAddress,
                                   int index):
    impl(SharedPtr(new NetworkInterfaceImpl(name, name, address, subnetMask, broadcastAddress, index))) {
}

NetworkInterface::~NetworkInterface() {}

NetworkInterface& NetworkInterface::operator = (const NetworkInterface& interfc) {
    NetworkInterface tmp(interfc);
    swap(tmp);
    return *this;
}

bool NetworkInterface::operator==(const NetworkInterface& interfc) const {
    if (impl) {
        if (interfc.impl) {
            return impl->equals(*interfc.impl);
        }
        else {
            return false;
        }
    }
    else {
        if (interfc.impl) {
            return false;
        }

        return true;
    }
}

void NetworkInterface::swap(NetworkInterface& other) {
    impl.swap(other.impl);
}

int NetworkInterface::getIndex() const {
    if (impl) {
        return impl->getIndex();
    }

    return 0;
}

const std::string& NetworkInterface::getName() const {
    if (impl) {
        return impl->getName();
    }

    //TODO
    return "";
}

const std::string& NetworkInterface::getDisplayName() const {
    if (impl) {
        return impl->getDisplayName();
    }

    return "";
}

const IpAddress& NetworkInterface::getIpAddress() const {
    if (impl) {
        return impl->getAddress();
    }

    return IpAddress::NULL_ADDRESS;
}

#if 0
const IpAddress& NetworkInterface::subnetMask() const {
    if (nullPtr == impl) {
        return IpAddress::NULL_ADDRESS;
    }

    return impl->getSubnetMask();
}

const IpAddress& NetworkInterface::getBroadcastAddress() const {
    if (nullPtr == impl) {
        return IpAddress::NULL_ADDRESS;
    }

    return impl->getBroadcastAddress();
}
#endif

bool NetworkInterface::isIPv6() const {
    if (impl) {
        return impl->getIndex() != -1;
    }

    return false;
}

NetworkInterface NetworkInterface::getByName(const std::string& name,
        bool requireIPv6) {
    NetworkInterfaceList ifs = getNetInterfaces();
    NetworkInterfaceList::const_iterator itr;

    for (itr = ifs.begin(); itr != ifs.end(); ++itr) {
        if (itr->getName() == name && ((requireIPv6 && itr->isIPv6()) || !requireIPv6)) {
            return *itr;
        }
    }

    return NULL_INTERFACE;
}

NetworkInterface NetworkInterface::geByIpAddress(const IpAddress& addr) {
    NetworkInterfaceList ifs = getNetInterfaces();
    NetworkInterfaceList::const_iterator itr;

    for (itr = ifs.begin(); itr != ifs.end(); ++itr) {
        if (itr->getIpAddress() == addr) {
            return *itr;
        }
    }

    return NULL_INTERFACE;
}

NetworkInterface NetworkInterface::getByIndex(int i) {
    if (i >= 0) {
        NetworkInterfaceList ifs = getNetInterfaces();
        NetworkInterfaceList::const_iterator itr;

        for (itr = ifs.begin(); itr != ifs.end(); ++itr) {
            if (itr->getIndex() == i) {
                return *itr;
            }
        }

        return NULL_INTERFACE;
    }

    return NULL_INTERFACE;
}

}
}

//
// platform-specific code below
//

#if BOOST_WINDOWS
//
// Windows
//
#include <winsock2.h>
#include <iphlpapi.h>

#if defined(BOOST_MSVC)
#pragma comment(lib, "Iphlpapi.lib")
#endif

namespace cetty {
namespace channel {

NetworkInterface::NetworkInterfaceList NetworkInterface::getNetInterfaces() {
    NetworkInterfaceList result;
    DWORD rc;

#if 0
    // On Windows XP/Server 2003 and later we use GetAdaptersAddresses.
    PIP_ADAPTER_ADDRESSES pAdapterAddresses;
    PIP_ADAPTER_ADDRESSES pAddress = 0;
    ULONG addrLen     = sizeof(IP_ADAPTER_ADDRESSES);
    pAdapterAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(new char[addrLen]);
    // Make an initial call to GetAdaptersAddresses to get
    // the necessary size into addrLen
    rc = GetAdaptersAddresses(AF_UNSPEC, 0, 0, pAdapterAddresses, &addrLen);

    if (rc == ERROR_BUFFER_OVERFLOW) {
        delete [] reinterpret_cast<char*>(pAdapterAddresses);
        pAdapterAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(new char[addrLen]);
    }
    else if (rc != ERROR_SUCCESS) {
        throw NetException("cannot get network adapter list");
    }

    try {
        if (GetAdaptersAddresses(AF_UNSPEC, 0, 0, pAdapterAddresses, &addrLen) == NO_ERROR) {
            pAddress = pAdapterAddresses;

            while (pAddress) {
                if (pAddress->FirstUnicastAddress) {
                    IPAddress addr;

                    switch (pAddress->FirstUnicastAddress->Address.lpSockaddr->sa_family) {
                    case AF_INET:
                        addr = IPAddress(&reinterpret_cast<struct sockaddr_in*>(pAddress->FirstUnicastAddress->Address.lpSockaddr)->sin_addr, sizeof(in_addr));
                        break;

                    case AF_INET6:
                        addr = IPAddress(&reinterpret_cast<struct sockaddr_in6*>(pAddress->FirstUnicastAddress->Address.lpSockaddr)->sin6_addr, sizeof(in6_addr));
                        break;
                    }

                    std::string name(pAddress->AdapterName);
                    std::string displayName;
#ifdef POCO_WIN32_UTF8
                    Poco::UnicodeConverter::toUTF8(pAddress->Description, displayName);
#else
                    char displayNameBuffer[1024];
                    int rc = WideCharToMultiByte(CP_ACP, WC_DEFAULTCHAR, pAddress->Description, -1, displayNameBuffer, sizeof(displayNameBuffer), NULL, NULL);

                    if (rc) { displayName = displayNameBuffer; }

#endif
                    result.push_back(NetworkInterface(name, displayName, addr, pAddress->Ipv6IfIndex));
                    pAddress = pAddress->Next;
                }
            }
        }
        else { throw NetException("cannot get network adapter list"); }
    }
    catch (Poco::Exception&) {
        delete [] reinterpret_cast<char*>(pAdapterAddresses);
        throw;
    }

    delete [] reinterpret_cast<char*>(pAdapterAddresses);
    return result;

#endif

    // Add IPv4 loopback interface (not returned by GetAdaptersInfo)
    result.push_back(NetworkInterface("Loopback", "Loopback Interface", IpAddress("127.0.0.1"), IpAddress("255.0.0.0"), IpAddress(), -1));

    // It is possible for an adapter to have multiple
    // IPv4 addresses, gateways, and secondary WINS servers
    // assigned to the adapter.
    PIP_ADAPTER_INFO adapterInfo;
    PIP_ADAPTER_INFO adapter = NULL;
    DWORD retVal = 0;
    ULONG outBufLen = sizeof(IP_ADAPTER_INFO);
    adapterInfo = (IP_ADAPTER_INFO*) malloc(sizeof(IP_ADAPTER_INFO));

    if (adapterInfo == NULL) {
        //printf("Error allocating memory needed to call GetAdaptersinfo\n");
        return result;
    }

    // Make an initial call to GetAdaptersInfo to get
    // the necessary size into the ulOutBufLen variable
    if (GetAdaptersInfo(adapterInfo, &outBufLen) == ERROR_BUFFER_OVERFLOW) {
        free(adapterInfo);
        adapterInfo = (IP_ADAPTER_INFO*) malloc(outBufLen);

        if (adapterInfo == NULL) {
            //printf("Error allocating memory needed to call GetAdaptersinfo\n");
            return result;
        }
    }

    if ((retVal = GetAdaptersInfo(adapterInfo, &outBufLen)) == NO_ERROR) {
        adapter = adapterInfo;

        while (adapter) {
            IpAddress address(std::string(adapter->IpAddressList.IpAddress.String));

            // only return interfaces that have an address assigned.
            if (!address.isWildcard()) {
                IpAddress subnetMask(std::string(adapter->IpAddressList.IpMask.String));
                IpAddress broadcastAddress(address);
                broadcastAddress.mask(subnetMask, IpAddress("255.255.255.255"));
                std::string name(adapter->AdapterName);
                std::string displayName(adapter->Description);
                result.push_back(NetworkInterface(name, displayName, address, subnetMask, broadcastAddress));
            }

            switch (adapter->Type) {
            case MIB_IF_TYPE_OTHER:
                break;

            case MIB_IF_TYPE_ETHERNET:
                break;

            case MIB_IF_TYPE_TOKENRING:
                break;

            case MIB_IF_TYPE_FDDI:
                break;

            case MIB_IF_TYPE_PPP:
                break;

            case MIB_IF_TYPE_LOOPBACK:
                break;

            case MIB_IF_TYPE_SLIP:
                break;

            default:
                break;
            }
        }
    }
    else {
    }

    if (adapterInfo) {
        free(adapterInfo);
    }

    return result;
}

}
}

#elif BOOST_NIX || BOOST_QNX
//
// BSD variants
//
#include <sys/types.h>
#include <sys/socket.h>
#include <ifaddrs.h>
#include <net/if_dl.h>

namespace cetty {
namespace channel {

NetworkInterface::NetworkInterfaceList NetworkInterface::getNetInterfaces() {
    NetworkInterfaceList result;

    struct ifaddrs* ifaphead;
    int rc = getifaddrs(&ifaphead);

    if (rc) {
        result;
    }

    for (struct ifaddrs* ifap = ifaphead; ifap; ifap = ifap->ifa_next) {
        if (ifap->ifa_addr) {
            if (ifap->ifa_addr->sa_family == AF_INET) {
                std::string name(ifap->ifa_name);
                IPAddress addr(&reinterpret_cast<struct sockaddr_in*>(ifap->ifa_addr)->sin_addr, sizeof(struct in_addr));
                IPAddress subnetMask(&reinterpret_cast<struct sockaddr_in*>(ifap->ifa_netmask)->sin_addr, sizeof(struct in_addr));
                IPAddress broadcastAddr;

                if (ifap->ifa_flags & IFF_BROADCAST) {
                    broadcastAddr = IPAddress(&reinterpret_cast<struct sockaddr_in*>(ifap->ifa_dstaddr)->sin_addr, sizeof(struct in_addr));
                }

                result.push_back(NetworkInterface(name, name, addr, subnetMask, broadcastAddr));
            }
            else if (ifap->ifa_addr->sa_family == AF_INET6) {
                IPAddress addr(&reinterpret_cast<struct sockaddr_in6*>(ifap->ifa_addr)->sin6_addr, sizeof(struct in6_addr));
                std::string name(ifap->ifa_name);
                result.push_back(NetworkInterface(name, name, addr, if_nametoindex(ifap->ifa_name)));
            }
        }
    }

    freeifaddrs(ifaphead);
    return result;
}

}
}

#elif BOOST_LINUX
//
// Linux
//
#include <sys/types.h>
#include <ifaddrs.h>

namespace cetty {
namespace channel {

NetworkInterface::NetworkInterfaceList NetworkInterface::getNetInterfaces() {
    NetworkInterfaceList result;
#if 0
    struct ifaddrs* ifaces = 0;
    struct ifaddrs* currIface = 0;

    if (getifaddrs(&ifaces) < 0) {
        throw NetException("cannot get network adapter list");
    }

    try {
        for (currIface = ifaces; currIface != 0; currIface = currIface->ifa_next) {
            IPAddress addr;
            bool haveAddr = false;

            switch (currIface->ifa_addr->sa_family) {
            case AF_INET6:
                addr = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(currIface->ifa_addr)->sin6_addr, sizeof(struct in6_addr));
                haveAddr = true;
                break;

            case AF_INET:
                addr = IPAddress(&reinterpret_cast<const struct sockaddr_in*>(currIface->ifa_addr)->sin_addr, sizeof(struct in_addr));
                haveAddr = true;
                break;

            default:
                break;
            }

            if (haveAddr) {
                int index = if_nametoindex(currIface->ifa_name);
                std::string name(currIface->ifa_name);
                result.push_back(NetworkInterface(name, name, addr, index));
            }
        }
    }
    catch (...) {
    }

    if (ifaces) { freeifaddrs(ifaces); }

#endif
    return result;
}

}
}


#else

//
// Non-BSD Unix variants
//
namespace cetty {
namespace channel {

NetworkInterface::NetworkInterfaceList NetworkInterface::getNetInterfaces() {
    NetworkInterfaceList result;
#if 0
    DatagramSocket socket;

    // the following code is loosely based
    // on W. Richard Stevens, UNIX Network Programming, pp 434ff.
    int lastlen = 0;
    int len = 100*sizeof(struct ifreq);
    char* buf = 0;

    try {
        struct ifconf ifc;

        for (;;) {
            buf = new char[len];
            ifc.ifc_len = len;
            ifc.ifc_buf = buf;

            if (::ioctl(socket.impl()->sockfd(), SIOCGIFCONF, &ifc) < 0) {
                if (errno != EINVAL || lastlen != 0) {
                    throw NetException("cannot get network adapter list");
                }
            }
            else {
                if (ifc.ifc_len == lastlen) {
                    break;
                }

                lastlen = ifc.ifc_len;
            }

            len += 10*sizeof(struct ifreq);
            delete [] buf;
        }

        for (const char* ptr = buf; ptr < buf + ifc.ifc_len;) {
            const struct ifreq* ifr = reinterpret_cast<const struct ifreq*>(ptr);
#if defined(POCO_HAVE_SALEN)
            len = ifr->ifr_addr.sa_len;

            if (sizeof(struct sockaddr) > len) { len = sizeof(struct sockaddr); }

#else
            len = sizeof(struct sockaddr);
#endif
            IPAddress addr;
            bool haveAddr = false;

            switch (ifr->ifr_addr.sa_family) {
            case AF_INET6:
                if (len < sizeof(struct sockaddr_in6)) { len = sizeof(struct sockaddr_in6); }

                addr = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(&ifr->ifr_addr)->sin6_addr, sizeof(struct in6_addr));
                haveAddr = true;
                break;

            case AF_INET:
                if (len < sizeof(struct sockaddr_in)) { len = sizeof(struct sockaddr_in); }

                addr = IPAddress(&reinterpret_cast<const struct sockaddr_in*>(&ifr->ifr_addr)->sin_addr, sizeof(struct in_addr));
                haveAddr = true;
                break;

            default:
                break;
            }

            if (haveAddr) {
                int index = if_nametoindex(ifr->ifr_name);
                std::string name(ifr->ifr_name);
                result.push_back(NetworkInterface(name, name, addr, index));
            }

            len += sizeof(ifr->ifr_name);
            ptr += len;
        }
    }
    catch (...) {
        delete [] buf;
        throw;
    }

    delete [] buf;
#endif
    return result;
}

}
}

#endif
